 Here is a Python3 solution using dynamic programming to solve the problem:
```python
import sys
from collections import defaultdict

def main(input):
    H, W, K = map(int, input.readline().strip().split())
    grid = [input.readline().strip() for _ in range(H)]

    # Initialize a 2D array to store the number of ways to color the grid
    # with the given top and left borders.
    dp = [[0] * (W + 1) for _ in range(H + 1)]

    # Initialize the first row and column of the dp array.
    dp[0][0] = 1
    for j in range(1, W + 1):
        dp[0][j] = dp[0][j - 1] + (1 if grid[0][j - 1] == '#' else 0)

    for i in range(1, H + 1):
        for j in range(W + 1):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]
            if j > 0 and grid[i - 1][j - 1] == '#':
                dp[i][j] += 1

    # Initialize a hashmap to store the number of ways to color the grid
    # with the given right border.
    count = defaultdict(int)
    for j in range(1, W + 1):
        count[dp[H][j]] += 1

    # Calculate the number of ways to color the grid with the given bottom border.
    result = 0
    for j in range(1, W + 1):
        temp = dp[H][j] - dp[H - 1][j]
        if grid[H - 1][j - 1] == '#':
            temp += 1
        result += count[K - temp]

    print(result)

if __name__ == '__main__':
    main(sys.stdin)
```
The basic idea is to use dynamic programming to precompute the number