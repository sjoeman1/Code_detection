 Here's a Python3 solution using dynamic programming to solve the problem:

```python
def min_mp(N, A, B, C, l):
    dp = [[float('inf') for _ in range(B+1)] for _ in range(A+1)]
    dp[C][l[C-1]] = 0

    for i in range(C+1, A+1):
        dp[i][l[i-1]] = 0
        for j in range(C, i):
            dp[i][l[i-1]] = min(dp[i][l[i-1]], dp[j][l[j-1]] + 10)
        for j in range(1, i+1):
            if l[j-1] >= i:
                dp[i][l[i-1]] = min(dp[i][l[i-1]], dp[i][l[i-1]-1] + 1)
            elif l[j-1] >= i - 1:
                dp[i][l[i-1]] = min(dp[i][l[i-1]], dp[i-1][l[j-1]] + 1)

    res = float('inf')
    for i in range(B+1):
        res = min(res, dp[A][i])

    return res

N, A, B, C = map(int, input().split())
l = [int(input()) for _ in range(N)]
print(min_mp(N, A, B, C, l))
```

The `min_mp` function calculates the minimum magic points required to obtain bamboos of lengths `A`, `B`, and `C` using dynamic programming. The state `dp[i][j]` represents the minimum magic points required to obtain a bamboo of length `i` with the last bamboo of length `j`. The function iterates over all possible lengths for the last bamboo and updates the minimum magic points required for each length `i` from `C` to `A`. Finally, the function returns the minimum magic points required to obtain a bamboo of length `A`.

The input format is as described