 Here is a Python3 solution for the problem:

```python
import sys
from collections import Counter

# Read input
N = int(input())
difficulties = list(map(int, input().split()))

# Count the number of problems with difficulty greater than i
counts = [0] * (max(difficulties) + 1)
for diff in difficulties:
    counts[diff] += 1

# Calculate the answer
ans = 0
for i in range(1, len(counts)):
    if counts[i] == counts[0] + i - 1:
        ans += 1
    elif counts[i] > counts[0] + i - 1:
        break

print(ans)
```

The idea is to count the number of problems with difficulty greater than i for all i=1, 2, ..., max(difficulties). Then, we can calculate the answer by checking the number of problems for ARCs (counts[i]) and the number of problems for ABCs (counts[0] + i - 1) for each i. The answer is the number of i such that the two numbers are equal.

Note that we can stop checking when counts[i] > counts[0] + i - 1 because the number of problems for ABCs is strictly increasing and the number of problems for ARCs is at most counts[0] + i - 1. Therefore, it is impossible to have counts[i] = counts[0] + i - 1 for larger i.

Also, we can use a Counter object instead of a list to count the number of problems with difficulty greater than i. It can make the code simpler and more efficient. However, the current implementation is already fast enough for the given constraints.