 Here is a Python3 solution for the problem:

```python
n, k = map(int, input().split())
a = list(map(int, input().split()))

# Count the frequency of each number in the array
counts = [0] * (2 * 10**5 + 1)
for num in a:
    counts[num] += 1

# Initialize the result as the number of distinct numbers
result = len(counts) - counts.count(0)

# If there are enough equal numbers, we can immediately stop
if counts[a[0]] >= k:
    print(0)
    exit()

# Binary search for the smallest number that can be merged to the first number
left, right = a[0], 2 * 10**5
while left < right:
    mid = (left + right) // 2
    # Count the number of numbers that can be merged to the first number
    mergeable = sum(count for count in counts if count > 0 and a[0] % (2 * mid) == 0)
    # If the number of mergeable numbers is greater than or equal to k - 1,
    # then we can merge the first number to mid and binary search in the left half
    if mergeable >= k - 1:
        right = mid
    else:
        left = mid + 1

# The result is the original result minus the number of mergeable numbers
# plus the number of times we need to merge the first number to the smallest mergeable number
result -= mergeable
result += (k - 1) // mergeable
print(result)
```

The idea is to count the frequency of each number in the array, and initialize the result as the number of distinct numbers. If there are enough equal numbers, we can immediately stop and output 0. Otherwise, we binary search for the smallest number that can be merged to the first number. We count the number of mergeable numbers, and if it is greater than or equal to k - 1, we can merge the first number to this smallest mergeable number. We repeat this process until the smallest mergeable number is greater than or equal to the first number. Finally, we subtract the number of mergeable numbers from the original