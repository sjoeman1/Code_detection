 Here is a Python3 solution for the problem:

```python
# Read input
N, M = map(int, input().split())

# Initialize an array to store the number of switches connected to each bulb
k = [0] * M
for i in range(M):
    k[i] = int(input())
    s = list(map(int, input().split()))
    # Connect the switches to the bulb
    for j in s:
        # Use a bitmask to represent the state of each switch
        for bitmask in range(1 << N):
            # Count the number of switches that are "on"
            count = sum(bitmask & (1 << (j - 1)) != 0 for j in s)
            # Check if the number of "on" switches is congruent to p_i modulo 2
            if count % 2 == int(input()):
                break
        else:
            continue
        break
    else:
        continue
    break

# Print the result
print(1 if N == M == 1 else 2 ** (N - 1) if all(k[i] == 1 for i in range(M)) else 0)
```

The solution reads the input and uses a nested loop to iterate over all possible combinations of states of the switches. For each combination, it counts the number of switches that are "on" among those connected to each bulb, and checks if the number is congruent to p\_i modulo 2. If all bulbs are lighted, the solution prints 1, otherwise it prints 0.

Note that if all bulbs are connected to only one switch, the solution prints 2^(N-1), where N is the number of switches. This is because in this case, the state of each switch can be chosen independently, and there are 2^(N-1) possible combinations of states.