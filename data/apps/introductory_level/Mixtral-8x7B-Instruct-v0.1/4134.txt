 Here is a Python3 solution using dynamic programming:

```python
import sys

input = sys.stdin.readline

def solve():
    n, m, k = map(int, input().split())
    dp = [[0] * (m+1) for _ in range(n+1)]
    dp[1][1] = 1
    for i in range(1, n+1):
        for j in range(1, m+1):
            dp[i][j] = dp[i-1][j] ^ dp[i][j-1] ^ a[i-1][j-1]
            if i > 1:
                dp[i][j] ^= dp[i-2][j]
            if j > 1:
                dp[i][j] ^= dp[i][j-2]
            if dp[i][j] == k:
                ans += 1
    print(ans)

a = []
for _ in range(n):
    a.append(list(map(int, input().split())))
ans = 0
solve()
```

This solution creates a 2D dynamic programming array `dp` where `dp[i][j]` represents the XOR of all numbers on the path from the top-left corner to the cell `(i, j)`. It then iterates over each cell in the grid and checks if the XOR of the path to that cell is equal to `k`. If it is, it increments the `ans` variable.

Note that the solution assumes that the input is given in the required format and it doesn't check for the edge cases.