 Here is a Python3 solution for the problem:

```python
def min_moves_to_divisible_by_25(n):
    # If the number is already divisible by 25, return 0
    if int(n) % 25 == 0:
        return 0
    
    # Convert the number to a list of digits
    digits = [int(digit) for digit in str(n)]
    
    # Keep track of the minimum number of moves
    min_moves = float('inf')
    
    # Function to check if a number is divisible by 25
    def is_divisible_by_25(num):
        return int(num) % 25 == 0
    
    # Function to try all possible swaps of adjacent digits
    def try_swaps(index, moves):
        nonlocal min_moves
        # If we have reached the end of the list, check if the number is divisible by 25
        if index == len(digits):
            if is_divisible_by_25(''.join(map(str, digits))):
                min_moves = min(min_moves, moves)
            return
        # Try swapping the current digit with the next one
        digits[index], digits[index + 1] = digits[index + 1], digits[index]
        try_swaps(index + 1, moves + 1)
        # Undo the swap
        digits[index], digits[index + 1] = digits[index + 1], digits[index]
        # Try not swapping the current digit with the next one
        try_swaps(index + 1, moves)
    
    # Start trying swaps from the first digit
    try_swaps(0, 0)
    
    # If it was impossible to obtain a number divisible by 25, return -1
    if min_moves == float('inf'):
        return -1
    else:
        return min_moves

# Read the input number
n = int(input())

# Print the minimum number of moves required