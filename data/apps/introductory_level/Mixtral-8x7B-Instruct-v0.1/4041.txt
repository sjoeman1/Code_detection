 Here is a Python3 solution for the problem:
```python
def max\_subarray\_remove(s, t):
    n, m = len(s), len(t)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    # backtrack to find the maximum subarray to remove
    i, j = n, m
    res = []
    while i > 0 and j > 0:
        if s[i - 1] == t[j - 1]:
            res.append(i - 1)
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return len(res)

# read input
s = input()
t = input()

# compute the maximum subarray to remove
res = max_subarray_remove(s, t)

# output the result
print(res)
```
The solution uses dynamic programming to compute the length of the longest common subsequence (LCS) between the two input strings `s` and `t`. The LCS is the longest string that can be obtained by removing some (possibly zero) number of characters from `s` and `t` without changing the order of the remaining characters.

The dynamic programming table `dp` is a 2D array where `dp[i][j]` is the length of the LCS of the substrings `s[:i]` and `t[:j]`. The table is computed using the following recurrence:
```makefile
dp[i][j] = dp[i - 1][j - 1] + 1                    if s[i