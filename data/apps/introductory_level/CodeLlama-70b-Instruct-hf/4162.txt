

Here's a possible Python 3 solution:

```
def max_f(a):
    n = len(a)
    mod_sum = [0] * n
    max_f = 0

    for i in range(n):
        for j in range(i, n):
            mod_sum[j] += a[i] - 1

    for i in range(n):
        max_f = max(max_f, mod_sum[i])

    return max_f

if __name__ == "__main__":
    n = int(input())
    a = list(map(int, input().split()))
    result = max_f(a)
    print(result)

```

This solution uses dynamic programming to solve the problem. We start by initializing an array `mod_sum` of size `n` with all zeros. Then, for each element `a[i]` in the array, we update `mod_sum` for all elements from index `i` to `n - 1` by adding `a[i] - 1` to each element. This is done to take into account all the possible remainders modulo `a[i]`.

Finally, we iterate through the `mod_sum` array and find the maximum value, which is the maximum value of `f`.

Please note that this is not the most efficient solution, but it should work for small values of `n` and `a[i]`. If you're interested in a more efficient solution, I can provide one, but I'll leave that to you to explore.