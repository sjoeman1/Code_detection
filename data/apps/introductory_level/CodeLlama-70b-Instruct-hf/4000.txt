

The solution to this problem is to find the diameter of the tree. The diameter is the longest path in a tree. We can find the diameter by performing a Depth First Search (DFS) or Breadth First Search (BFS) from an arbitrary vertex. Once we find the diameter, we can find the three vertices that satisfy the given conditions by finding the midpoint of the diameter and choosing the vertices on either side of the midpoint.

Here's the Python code to solve this problem:

```python
from collections import defaultdict, deque

# Find the diameter of the tree
def find_diameter(n, edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    # Choose an arbitrary vertex as the root
    root = 1

    # Perform DFS to find the farthest vertex from the root
    dist = {}
    max_dist = 0
    farthest_vertex = None
    for vertex in range(1, n + 1):
        if vertex not in dist:
            queue = deque([(vertex, 0)])
            dist[vertex] = 0
            while queue:
                current, distance = queue.popleft()
                for neighbor in graph[current]:
                    if neighbor not in dist:
                        dist[neighbor] = distance + 1
                        queue.append((neighbor, dist[neighbor]))
            max_dist = max(max_dist, dist[vertex])
            farthest_vertex = vertex

    # Perform DFS again to find the farthest vertex from the farthest vertex
    dist = {}
    max_dist = 0
    farthest_vertex2 = None
    for vertex in range(1, n + 1):
        if vertex not in dist:
            queue = deque([(vertex, 0)])
            dist[vertex] = 0
            while queue:
                current, distance = queue.popleft()
                for neighbor in graph[current]:
                    if neighbor not in dist:
                        dist[neighbor] =