```python
n = int(input())
q = list(map(int, input().split()))

# Check if the given array is valid
if not (1 <= n <= 2 * 10 ** 5 and len(q) == n - 1 and -n < q[i] < n for i in range(len(q))):
    print(-1)

# Calculate the prefix sum of q
prefix_sum = []
prefix_sum.append(q[0])
for i in range(1, len(q)):
    prefix_sum.append(prefix_sum[i - 1] + q[i])

# Find the unique solution
p = []
for i in range(n):
    p.append(prefix_sum[i] - prefix_sum[i - 1])

# Print the solution
print(*p)
```

**Explanation:**

The key to restoring the permutation is to calculate the prefix sum of the array `q` and then find the unique solution that satisfies the following conditions:

* The sum of the first `i` elements of `p` is equal to the prefix sum of `q` up to the `i-th` element.
* The elements of `p` are in the range `[1, n]`.

Once we have found the unique solution, we print it.

**Time complexity:**

The time complexity of this algorithm is O(n).

**Space complexity:**

The space complexity of this algorithm is O(n).