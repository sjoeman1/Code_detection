

Here is a solution in Python 3:

```python
# Input the number of cubes
n = int(input())

# Initialize a list to store the digits of each cube
cubes = []

# Take the input for each cube
for i in range(n):
    cubes.append(list(map(int, input().split())))

# Initialize the largest number x
x = 0

# Function to check if the number can be made using the cubes
def can_make(number):
    # Initialize a variable to store the current number
    current_number = ""
    # Iterate through each digit of the number
    for digit in str(number):
        # Initialize a variable to check if the digit can be made
        can_make_digit = False
        # Iterate through each cube
        for cube in cubes:
            # Check if the digit is on one of the cube faces
            if int(digit) in cube:
                # If the digit is found, add it to the current number
                current_number += digit
                can_make_digit = True
                break
        # If the digit cannot be made, return False
        if not can_make_digit:
            return False
    # If all digits can be made, return True
    return True

# Iterate through all possible numbers from 1 to 1000000
for i in range(1, 1000000):
    # Check if the number can be made using the cubes
    if can_make(i):
        # If the number can be made, update the largest number x
        x = i
    else:
        # If the number cannot be made, break out of the loop
        break

# Print the largest number x
print(x)
```

The solution first takes the input for the number of cubes and the digits on each cube face. Then, it defines a function `can_make` to check if a given number can be made using the cubes. For each digit in the number, it iterates through each cube to see if the digit is on one of the cube faces. If all digits can be made, it updates the largest number `x`. If any number cannot be made, it