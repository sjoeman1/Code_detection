 Here is a Python3 solution using Depth-First Search (DFS) to detect cycles in the graph:

```python
from collections import defaultdict

def detect_cycle(n, edges):
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)

    visited = set()
    recursion_stack = set()

    def dfs(node):
        if node in recursion_stack:
            return True
        if node in visited:
            return False

        recursion_stack.add(node)
        visited.add(node)
        for neighbor in graph[node]:
            if dfs(neighbor):
                return True
        recursion_stack.remove(node)
        return False

    for vertex in range(1, n+1):
        if dfs(vertex):
            return True

    return False

def main():
    n, m = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(m)]

    if detect_cycle(n, edges):
        print("NO")
    else:
        # If the graph has a cycle, removing any edge will make it acyclic.
        # If the graph is already acyclic, removing at most one edge will still keep it acyclic.
        print("YES")

if __name__ == "__main__":
    main()
```

This solution first builds the graph using the input edges and then performs a DFS on the graph to detect cycles. If a cycle is found, removing any edge from the cycle will make the graph acyclic. If no cycle is found, then the graph is already acyclic, and removing at most one edge will keep it acyclic.