 Here is a possible Python3 solution for the problem:

```python
mod = 10**9 + 7

def solve(n, p, c):
    dp_even = [[0] * 2 for _ in range(n)]
    dp_even[0][c[0] + 1] = 1
    dp_odd = [[0] * 2 for _ in range(n)]
    dp_odd[0][c[0] + 1] = 1
    for i in range(1, n):
        if c[i] == -1:
            dp_even[i][0] = dp_odd[i-1][1]
            dp_even[i][1] = dp_odd[i-1][0] + dp_odd[i-1][1]
            dp_odd[i][0] = dp_even[i-1][1]
            dp_odd[i][1] = dp_even[i-1][0] + dp_even[i-1][1]
        else:
            dp_even[i][c[i]] = dp_odd[i-1][1-c[i]]
            dp_odd[i][c[i]] = dp_even[i-1][1-c[i]]
            dp_even[i][1-c[i]] = dp_odd[i-1][c[i]]
            dp_odd[i][1-c[i]] = 0
    if p == 0:
        return sum(dp_even[n-1]) % mod
    else:
        return sum(dp_odd[n-1]) % mod

n, p = map(int, input().split())
c = list(map(int, input().split()))
print(solve(n, p, c))
```

The solution uses dynamic programming to compute the number of ways to color the pieces and add arrows for each prefix of the pieces. The state of the dynamic programming is represented by two 2D arrays `dp_even` and `dp_odd`, where `dp_even[i][j]` (`dp_odd[i][j]`) is the number of ways to color the first