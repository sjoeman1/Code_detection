 Here's a Python3 solution using a data structure called "Binary Indexed Tree" or "Fenwick Tree" to efficiently update and query the number of inversions in the current permutation.

The idea is to start with the identity permutation, then simulate the swaps by updating the permutation and computing the number of inversions after each swap.

To update the number of inversions efficiently, we use a Binary Indexed Tree, which allows us to query and update the prefix sum of an array efficiently.

The time complexity of this solution is O(n log n + k log n) where n is the number of cows and k is the length of Farmer John's nap.

```python
import sys
input = sys.stdin.readline

def update(bit, i, x):
    while i <= n:
        bit[i] += x
        i += i & -i

def query(bit, i):
    s = 0
    while i > 0:
        s += bit[i]
        i -= i & -i
    return s

def max_messiness(n, k):
    bit = [0] * (n + 1)
    inv = 0
    for i in range(1, n + 1):
        inv += query(bit, n) - query(bit, i)
        update(bit, i, 1)
    for _ in range(k - 1):
        i = query(bit, n) - query(bit, n - 1)
        j = query(bit, n) - query(bit, i)
        update(bit, i, -1)
        update(bit, j + 1, 1)
    return inv

if __name__ == '__main__':
    n, k = map(int, input().strip().split())
    print(max_messiness(n, k))
```

Note: The `query` function returns the sum of the elements in the range [1, i] of the array, and the `update` function increments the value of the element at index `i` by `x`. The `inv` variable stores the total number of inversions in the current