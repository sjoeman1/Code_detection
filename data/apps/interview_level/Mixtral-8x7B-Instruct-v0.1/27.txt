 Here is a Python3 solution for the problem:

```python
def min\_operations(n, s):
if n == 1:
return 1

dp = [0] \* (n + 1)
dp[0], dp[1] = 0, 1

for i in range(2, n + 1):
dp[i] = i
for j in range(1, i // 2 + 1):
if s[j - 1] == s[i - 1]:
dp[i] = min(dp[i], dp[j] + 1)

return dp[n]

n = int(input())
s = input()

print(min\_operations(n, s))
```

The solution uses dynamic programming to store the minimum number of operations required to type the first i characters of the string. The base case is when there is only one character, which requires only 1 operation. For longer strings, we initialize the i-th element of the dp array to i, as that is the maximum number of operations required to type the first i characters. Then, for each i from 2 to n, we check if the i-th character is the same as any of the previous characters. If it is, we update dp[i] to be the minimum of its current value and dp[j] + 1, where j is the index of the previous character that matches the i-th character. Finally, we return dp[n] as the answer.

Note that the additional operation of copying the string and appending it to itself is not explicitly used in the solution, as it is not necessary to achieve the minimum number of operations. The solution only considers typing each character one by one, and copying a substring when it is beneficial to do so.