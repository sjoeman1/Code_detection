 Here is a Python3 solution for the problem:

```python
def solve():
    n, x = map(int, input().split())
    s = input()
    cnt0, cnt1, cur_balance = 0, 0, 0
    ans = 0
    for i in range(n):
        if s[i] == '0':
            cnt0 += 1
        else:
            cnt1 += 1
        cur_balance = cnt0 - cnt1
        if cur_balance == x:
            ans += 1
        elif cur_balance > x:
            break
    if cur_balance == x:
        print(ans + 1)
    elif cur_balance > x:
        print(-1)
    else:
        if x > 0:
            print(0)
        else:
            print(1)

T = int(input())
for _ in range(T):
    solve()
```

This solution uses a simple iterative approach. We keep track of the current balance, the number of 0's and 1's in the current prefix. We also keep track of the answer, which is the number of prefixes with balance equal to `x`.

At each iteration, we check if the current balance is equal to `x`. If it is, we increment the answer by 1. If it is greater than `x`, we break the loop, as the balance will only increase in the future.

After the loop, we check if the current balance is equal to `x`. If it is, we print the answer plus 1 (as the current prefix is also a valid one). If it is greater than `x`, we print -1. If `x` is 0 and the current balance is less than 0, we print 1 (as the empty prefix has balance 0). Otherwise, we print 0.