 Here is a Python3 solution for the problem:

```python
def min\_length\_to\_reach\_target(n, ops, x, y):
dx, dy = 0, 0
for i, op in enumerate(ops):
global\_idx = i
if op == 'R':
dx += 1
elif op == 'L':
dx -= 1
elif op == 'U':
dy += 1
elif op == 'D':
dy -= 1
if dx == x and dy == y:
return 0

# If the robot cannot reach the target position
if dx != x or dy != y:
return -1

# Binary search to find the minimum subarray
left, right = 0, n - 1
while left <= right:
mid = (left + right) // 2
if ops[mid] == 'R' and mid + dx > n or ops[mid] == 'L' and mid - dx < 0 or ops[mid] == 'U' and mid + dy > n or ops[mid] == 'D' and mid - dy < 0:
right = mid - 1
else:
left = mid + 1

return max(dx, dy, right - left + 1)
```

The function `min_length_to_reach_target` takes three arguments: `n` (the number of operations), `ops` (the sequence of operations), and `x, y` (the target coordinates). It returns the minimum length of the subsegment that needs to be changed so that the robot will end up in the target cell.

The function first initializes `dx` and `dy` to 0, and then iterates through the sequence of operations. If the current operation moves the robot in the positive x-direction, it increments `dx`; if it moves the robot in the negative x-direction, it decrements `dx`; if it moves the robot in the positive y-direction, it increments `dy`; and if it moves the robot in the negative y-direction, it decrements `dy`. If the robot reaches the target position after iterating through the entire sequence, the function returns 0, indicating that no changes are needed.

If the robot cannot reach the target position, the function returns