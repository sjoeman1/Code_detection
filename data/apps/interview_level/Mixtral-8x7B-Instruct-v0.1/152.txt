 Here is a Python3 solution for the problem. This solution uses binary search to find the minimum time needed to prepare at least `n` potions.

```python
import math

def can_prepare(n, m, k, x, s, a, b, c, d, time):
    mana = s
    potions = 0

    # check spells of the first type
    for i in range(m):
        if mana >= b[i] and a[i] <= time:
            mana -= b[i]
            time = a[i]

    # check spells of the second type
    for i in range(k):
        if mana >= d[i] and potions + c[i] >= n:
            mana -= d[i]
            potions += c[i]
            if potions >= n:
                break

    # check remaining time
    if potions < n:
        time_needed = math.ceil((n - potions) / (x / time)) * (x / time)
    else:
        time_needed = 0

    return time + time_needed <= time, time_needed

def solution(n, m, k, x, s, a, b, c, d):
    left, right = 1, x
    while left < right:
        time = (left + right) // 2
        if can_prepare(n, m, k, x, s, a, b, c, d, time)[0]:
            right = time
        else:
            left = time + 1
    return left

# example 1
n, m, k = 20, 3, 2
x, s = 10, 99
a = [2, 4, 3]
b = [20, 10, 40]
c = [4, 15]
d = [10, 80]
print(solution(n, m, k, x, s, a, b, c, d))  # 20

# example 2
n, m, k = 20, 3, 