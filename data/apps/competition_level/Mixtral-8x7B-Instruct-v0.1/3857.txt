 Here is a Python3 solution for the problem:

```python
n = int(input())
xi = list(map(int, input().split()))

# Initialize the number of piles to 0
piles = 0

# Iterate over the boxes from right to left
for i in range(n - 1, -1, -1):
    # If the current box can't support any more boxes, we need to start a new pile
    if xi[i] == 0:
        piles += 1
    # Otherwise, we can add the current box to the top of the previous pile
    # We just need to make sure that the previous pile has enough capacity
    # To do this, we update the capacity of the previous pile to be the minimum of its current capacity and the strength of the current box
    else:
        xi[i - 1] = min(xi[i - 1], xi[i])

print(piles)
```

The solution works by iterating over the boxes from right to left and maintaining the current capacity of the top box of the previous pile. If the current box has a strength of 0, we need to start a new pile. Otherwise, we can add the current box to the top of the previous pile, as long as the previous pile has enough capacity. We update the capacity of the previous pile to be the minimum of its current capacity and the strength of the current box. At the end, we print the number of piles that we have created.

This solution has a time complexity of O(n), where n is the number of boxes. It also has a space complexity of O(1), since we only need to store a constant number of variables.