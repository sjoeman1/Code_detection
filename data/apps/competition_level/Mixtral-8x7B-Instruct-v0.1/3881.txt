 Here is a Python3 solution for the problem:

```python
def solve(n, q, operations):
    # Initialize the table to store the number of ways to reach each string
    dp = [0] * (n + 1)
    dp[0] = 1

    # Iterate over each possible length of the starting string
    for i in range(1, n + 1):
        # Iterate over each possible operation
        for a, b in operations:
            # If the first two characters of the current string match the operation
            if i >= 2 and a[0] == s[i - 2] and a[1] == s[i - 1]:
                # Add the number of ways to reach the previous string using this operation
                dp[i] += dp[i - 2]

    # Return the number of ways to reach the string "a"
    return dp[n]

n, q = map(int, input().split())
operations = []
for _ in range(q):
    a, b = input().split()
    operations.append((a, b))

s = "a" * n
print(solve(n, q, operations))
```

This solution uses dynamic programming to keep track of the number of ways to reach each possible string. The `dp` table stores the number of ways to reach a string of a given length. At each step, we iterate over each possible operation and add the number of ways to reach the previous string using that operation to the current string's count.

At the end, we return the number of ways to reach the string "a" of length `n`.

Note that this solution assumes that the input is well-formed and that the first two letters of each operation match some substring of the current string. If this is not the case, the solution may not work correctly.