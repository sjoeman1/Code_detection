 Here is a Python3 solution for the problem. The solution uses dynamic programming and matrix exponentiation to calculate the number of valid spanning trees. The time complexity of this solution is O(N^3 \* log(N)), where N is the number of vertices.

```python
import sys
input = sys.stdin.readline

def mul(a, b):
    c = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                c[i][j] += a[i][k] * b[k][j]
                c[i][j] %= mod
    return c

def pow(a, n):
    if n == 1:
        return a
    res = pow(a, n // 2)
    res = mul(res, res)
    if n % 2:
        res = mul(res, a)
    return res

def solve(n, m, edges, x):
    g = [[0] * n for _ in range(n)]
    for u, v, w in edges:
        g[u - 1][v - 1] = w
        g[v - 1][u - 1] = w

    # precalculate g^(n-2)
    g = pow(g, n - 2)

    # dp[i][j][k] = number of spanning trees with i black edges, j white edges, and total weight k
    dp = [[[0] * (x + 1) for _ in range(m + 1)] for _ in range(n)]
    for i in range(n):
        for j in range(m + 1):
            dp[i][j][0] = 1

    # iterate over number of black edges
    for k in range(1, n):
        # iterate over number of white edges
        for j in range(1, m + 1):
            # iterate over possible weights
            for w in range(1, x + 1):
                for l in range(1, j + 1):
                   