 To solve this problem, we need to use dynamic programming to keep track of the maximum number of nodes that Aroma can collect if she starts from a certain node and has a certain amount of time left. The state of the dynamic programming is defined as `dp[i][j]`, which represents the maximum number of nodes that Aroma can collect if she starts from the node `i` and has `j` seconds left.

Here is the Python3 code for solving the problem:

```python
def max\_nodes(x0, y0, ax, ay, bx, by, xs, ys, t):
x, y = xs, ys
dp = [[0 for _ in range(t + 1)] for _ in range(1000016)]
for j in range(t + 1):
dp[0][j] = 1 if j >= abs(xs - x0) + abs(ys - y0) else 0
for i in range(1, 1000016):
x, y = (ax * (x + bx) + by) % 1000016, (ay * (y + by) + bx) % 1000016
for j in range(t + 1):
dp[i][j] = dp[i - 1][j]
if j >= abs(xs - x) + abs(ys - y):
dp[i][j] = max(dp[i][j], dp[i - 1][j - (abs(xs - x) + abs(ys - y))] + 1)
return max(dp[-1])

x0, y0, ax, ay, bx, by = map(int, input().split())
xs, ys, t = map(int, input().split())
print(max\_nodes(x0, y0, ax, ay, bx, by, xs, ys, t))
```

The time complexity of this solution is O(t^2), where t is the maximum time available. The space complexity is O(t^2) as well, which can be reduced to O(t) using a 1D array. However, the current solution should be sufficient