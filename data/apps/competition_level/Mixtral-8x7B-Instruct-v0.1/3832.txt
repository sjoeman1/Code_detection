 Here is a Python3 solution for the problem:

```python
import math

def min_time_to_build_houses():
    n = int(input().strip())
    heights = list(map(int, input().strip().split()))

    min_times = []
    for k in range(1, math.ceil(n/2) + 1):
        min_time = 0
        left, right = 0, 0
        while right < n - 1:
            if heights[right] < heights[right + 1]:
                right += 1
            elif left < right and heights[left] < heights[right + 1]:
                heights[left], heights[right + 1] = heights[right + 1], heights[left]
                min_time += 1
                right += 1
            else:
                left += 1
                right += 1
        if heights[0] > heights[1]:
            heights[0], heights[1] = heights[1], heights[0]
            min_time += 1
        if k > 1 and heights[-1] > heights[-2]:
            heights[-1], heights[-2] = heights[-2], heights[-1]
            min_time += 1
        min_times.append(min_time)

    print(' '.join(map(str, min_times)))

min_time_to_build_houses()
```

The solution uses a sliding window approach to find the minimum number of hours required to level the hills so that at least `k` hills satisfy the condition. For each `k` in the range `[1, n/2]`, the algorithm iterates through the hills and checks if the current hill is lower than the next hill. If it is, the algorithm increments a counter. If the current hill is the left end of the sliding window, the algorithm swaps the current hill and the next hill, and increments the counter. If the current hill is the right end of the sliding window and the left end of the sliding window has already been swapped, the algorithm swaps the current hill and the