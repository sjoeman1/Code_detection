 Here is a Python3 solution for the problem:

```python
def solve(n, l, r):
    nums = [n]
    while True:
        new\_nums = []
        for x in nums:
            if x <= 1:
                new\_nums.append(x)
            else:
                new\_nums.append(x % 2)
                new\_nums.append(x // 2)
        nums = new\_nums
        if len(nums) == len(set(nums)):
            break
    return sum(num[l-1:r] == 1 for num in ([int(i=='1') for i in bin(x)[2:]] for x in nums))

# Test cases
print(solve(7, 2, 5))  # 4
print(solve(10, 3, 10))  # 5
```

The function `solve` takes in three arguments: `n`, `l`, and `r`, and returns the number of 1's in the range `l` to `r` in the final sequence.

The function first initializes a list `nums` with the single element `n`. Then, it enters a while loop that continues until the list `nums` does not change in the current iteration. In each iteration, the function creates a new list `new_nums` that is the result of applying the required operations on the elements of `nums`. If an element is 0 or 1, it is added to `new_nums` as is. Otherwise, it is divided by 2 and its remainder is added to `new_nums` sequentially. Once the new list `new_nums` is created, it is assigned to `nums` and the loop continues.

Once the loop is finished, the function calculates the number of 1's in the range `l` to `r` by converting each number in `nums` to a binary string and checking if the `l`-th to `r`-th characters of the string are 1. The binary string is obtained by removing the leading '0b' from the binary representation of the number, which is obtained