 Here is a Python3 solution for the problem:

```python
import sys
input = sys.stdin.readline

def power(x, y, mod):
    res = 1
    while y > 0:
        if y % 2:
            res = (res * x) % mod
            y -= 1
        x = (x * x) % mod
        y //= 2
    return res

def count_wool_seq(n, m, mod):
    dp = [0] * (n + 1)
    dp[0] = 1
    for i in range(n):
        for j in range(m):
            dp[i + 1] = (dp[i + 1] + dp[i]) % mod
            if j & 1:
                dp[i + 1] = (dp[i + 1] - dp[max(0, i - (1 << j) + 1)] + mod) % mod
    return (power(2, n, mod) - dp[n] + mod) % mod

n, m = map(int, input().split())
print(count_wool_seq(n, m, 1000000009))
```

The function `count_wool_seq` calculates the number of sequences that are not wool sequences. It uses dynamic programming to calculate the number of valid sequences of length `i` for `i` from `0` to `n`. The base case is `dp[0] = 1`, since there is only one sequence of length `0`. For each `i` and `j`, we calculate `dp[i + 1]` by adding `dp[i]` (since we can append any number to a valid sequence of length `i` to get a valid sequence of length `i + 1`). However, if `j` is odd, we need to subtract the number of sequences that end with `(1 << j)` (since they will result in a wool sequence when we append `0` to them). Finally, we return `2^n - dp[n]` (since the total number of sequences is `2^n`, and we need to subtract the number