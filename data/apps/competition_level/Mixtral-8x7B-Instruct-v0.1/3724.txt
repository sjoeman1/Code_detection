 Here is a Python3 solution using dynamic programming to solve the problem:
```python
import sys
input = sys.stdin.readline

MOD = 1000000007

N = int(input().strip())
S = input().strip()

dp = [[0, 0, 0] for _ in range(N)] # dp[i][j]: number of distinct strings ending with j (j: 0(A), 1(B), 2(C)) after i operations
dp[0][ord(S[0]) - ord('A')] = 1

for i in range(1, N):
    if i == 1:
        dp[i][(ord(S[i]) - ord('A')) % 3] += 1
        dp[i][(ord(S[i]) - ord('A')) % 3 + 1] += 1
    else:
        dp[i][ord(S[i]) - ord('A')] = dp[i-1][(ord(S[i]) - ord('A')) % 3]
        dp[i][(ord(S[i]) - ord('A')) % 3 + 1] = max(dp[i-1][(ord(S[i]) - ord('A')) % 3], dp[i-1][(ord(S[i]) - ord('A')) % 3 + 1]) + 1
        dp[i][(ord(S[i]) - ord('A')) % 3 - 1] = max(dp[i-1][(ord(S[i]) - ord('A')) % 3 - 1], dp[i-1][(ord(S[i]) - ord('A')) % 3])

print(sum(dp[-1]) % MOD)
```
The idea is to keep track of the number of distinct strings ending with each character (A, B, or C) after each operation. At each step, we have three options: replace the current character with the one that is different from both the current and the previous character, replace the current character with the one that is the same as the previous character, or do nothing. For each option, we update the number of distinct strings