 Here is one possible solution for the problem:

```python
import random

def is_valid(n, m, maze, k):
    # Check if the current maze has k empty cells that can be turned into walls
    count = 0
    for i in range(1, n-1):
        for j in range(1, m-1):
            if maze[i][j] == '.' and count < k:
                count += 1
            elif maze[i][j] == '.':
                return False
    return count == k

def random_maze(n, m, k):
    # Generate a random maze with k empty cells that can be turned into walls
    maze = [['#'] * (m+2) for _ in range(n+2)]
    for i in range(1, n+1):
        for j in range(1, m+1):
            maze[i][j] = '.' if random.random() < 1 - k/(n*m-1) else '#'
    return maze

def solve(n, m, k, maze):
    # Turn k empty cells into walls to make the maze connected
    while not is_valid(n, m, maze, k):
        k -= 1
        maze = random_maze(n, m, k)
    for i in range(1, n+1):
        for j in range(1, m+1):
            if maze[i][j] == '#' and k > 0:
                maze[i][j] = '.'
                k -= 1
    return maze

n, m, k = map(int, input().split())
maze = [list(input()) for _ in range(n)]

maze = solve(n, m, k, maze)

for i in range(n):
    print(''.join(maze[i]))
```

This solution first generates a random maze with k empty cells that can be turned into walls. Then, it turns k empty cells into walls one by one, until the remaining empty cells form a connected area.

Note that this