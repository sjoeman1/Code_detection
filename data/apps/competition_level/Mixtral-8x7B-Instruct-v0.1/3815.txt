 Here is a Python3 solution for the problem:

```python
def pow_mod(x, y, mod):
    res = 1
    while y > 0:
        if y % 2:
            res = (res * x) % mod
            y -= 1
        x = (x * x) % mod
        y //= 2
    return res % mod

def solve():
    n, a, b, k = map(int, input().split())
    s = input()
    seq = [1, -1] if s[0] == '-' else [1, 1]
    for i in range(1, k):
        if s[i] == '+':
            seq.append(seq[-1] * a)
        else:
            seq.append(seq[-1] * a * -1)
    for i in range(k, n + 1):
        seq.append(seq[i % k])
    ans = 0
    for i in range(n + 1):
        ans = (ans + seq[i] * pow_mod(a, n - i, 1000000000 + 9) * pow_mod(b, i, 1000000000 + 9)) % (1000000000 + 9)
    print(ans)

solve()
```

The solution first calculates the sequence `seq` using the given information. Then, it calculates the sum `ans` using the formula given in the problem statement. Note that the function `pow_mod` is used to calculate `a^(n-i)` and `b^i` modulo `1000000000 + 9` to avoid overflow. Finally, the program prints the value of `ans` modulo `1000000000 + 9`.