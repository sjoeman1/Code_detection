 Here is a Python3 solution that uses dynamic programming to solve the problem:
```
n = int(input())
s = input()

# Initialize the dynamic programming array
dp = [[0, 0] for _ in range(n)]

# Set the base cases
dp[0][0] = 1
dp[0][1] = 0 if s[0] == '0' else 1

# Iterate through the string
for i in range(1, n):
    dp[i][0] = max(dp[i - 1])
    dp[i][1] = dp[i - 1][0] + (1 if s[i] == '0' else 0)

# Set the base cases for the reversed string
dp_r = [[0, 0] for _ in range(n)]
dp_r[n - 1][0] = 1
dp_r[n - 1][1] = 0 if s[n - 1] == '1' else 1

# Iterate through the reversed string
for i in range(n - 2, -1, -1):
    dp_r[i][0] = max(dp_r[i + 1])
    dp_r[i][1] = dp_r[i + 1][0] + (1 if s[i] == '1' else 0)

# Initialize the answer
ans = max(dp[n - 1])

# Iterate through the string and check the reversed string
for i in range(n):
    ans = max(ans, dp[i][0] + dp_r[i][1])

# Print the answer
print(ans)
```
The basic idea is to use dynamic programming to calculate the length of the longest alternating subsequence ending at each position of the string. We also do the same for the reversed string. Then, we iterate through the string and, at each position, add the length of the longest alternating subsequence ending at that position in the string to the length of the longest alternating subsequence ending at that position in the reversed string, and keep track of the maximum value found.

This solution runs in O(n) time