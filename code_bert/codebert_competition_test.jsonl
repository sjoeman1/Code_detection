{"code": "n = int(input())\ns = [int(x) for x in input().split()]\ng = [int(x) for x in input().split()]\n\ns_i = [0 for _ in range(n)]\ns_i[0] = s[0]\n\nfor i in range(1, n):\n    if s_i[i - 1] - 1 <= s[i] + g[i] and s_i[i - 1] + 1 >= s[i]:\n        s_i[i] = s_i[i - 1]\n    else:\n        s_i[i] = s[i] + g[i]\n\nprint(sum(s_i))\nprint(*s_i)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "s = input()\nt = input()\noverlap = t\ntt = ''\nfor i in range(len(t) - 1):\n    tt = tt + t[i]\n    if (t.endswith(tt)):\n        overlap = t[i + 1:]\nzro = s.count('0')\nmek = s.count('1')\nzro_tum = t.count('0')\nmek_tum = t.count('1')\nzro_toxum = overlap.count('0')\nmek_toxum = overlap.count('1')\n\nif (zro >= zro_tum and mek >= mek_tum):\n    print(t, end='')\n    zro -= zro_tum\n    mek -= mek_tum\nif zro_toxum:\n    k = zro//zro_toxum\nelse:\n    k = 10000000000\nif mek_toxum:\n    n = mek//mek_toxum\nelse:\n    n = 10000000000\nans = min(n, k)\nprint(overlap * ans, end='')\nzro -= zro_toxum * ans\nmek -= mek_toxum * ans\nprint('0' * zro + '1' * mek)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "m,n=list(map(int,input().split()))\n\nP=1\nans=0\n\nwhile(m>0):\n    p=P*(1-(((m-1)/m)**n))\n    ans+=m*p\n    m-=1\n    P-=p\nprint(ans)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "import sys\nn=int(input())\na=[]\n\nfor x in input().split():\n    if(int(x)!=int(0)):\n        a.append(int(x))\n\nif(len(a)>500):\n    print(3)\n    return\n\nn=len(a)\n\n#print(n)\n\ng=[]\nfor i in range(n):\n   g.append([])\n\nfor i in range(n):\n    for j in range(n):\n        g[i].append(1000000000)\n\nfor i in range(n):\n    for j in range(n):\n        if(i!=j and (a[i]&a[j])!=0):\n            g[i][j]=1\n\n\nans=int(10000000000)\n\ndis=[]\nfor i in range(n):\n    dis.append([])\n\nfor i in range(n):\n    for j in range(n):\n        dis[i].append(g[i][j])\n\nfor  k in range(n):\n    for i in range(k):\n        for j in range(i+1,k):\n            ans=min(ans,dis[i][j]+g[i][k]+g[k][j])\n    for i in range(n):\n        for j in range(n):\n            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])\n\n\n\nif(ans>1000):\n    print(-1)\nelse:\n    print(ans)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from math import gcd\n\nfrom math import factorial as f\n\nfrom math import ceil, floor, sqrt\nimport math\n\nimport bisect\nimport re\nimport heapq\n\nfrom copy import deepcopy\nimport itertools\nfrom itertools import permutations\n\nii = lambda: int(input())\nmi = lambda: list(map(int, input().split()))\nli = lambda: list(map(int, input().split()))\n\nyes = \"Yes\"\nno = \"No\"\n\n\ndef main():\n    a, b = mi()\n    print((100, 100))\n    ans = [[] for i in range(100)]\n    for i in range(50):\n        for j in range(100):\n            ans[i].append('#')\n    for i in range(50, 100):\n        for j in range(100):\n            ans[i].append('.')\n\n    for i in range(a - 1):\n        ans[2 * (i // 50)][2 * (i % 50)] = '.'\n    for i in range(b - 1):\n        ans[99 - 2 * (i // 50)][2 * (i % 50)] = '#'\n\n    for i in range(100):\n        print((''.join(ans[i])))\n\n\nmain()\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from heapq import heappush, heappop\n\n# Read the number of bottles\nn = int(input())\n\n# Read the amount of soda remaining in each bottle\na = list(map(int, input().split()))\n\n# Read the volume of each bottle\nb = list(map(int, input().split()))\n\n# Initialize a list to store the remaining soda in each bottle\nsoda = []\n\n# Iterate through each bottle\nfor i in range(n):\n    # Calculate the remaining soda in the bottle\n    remaining = b[i] - a[i]\n    # If there is remaining soda, add it to the list\n    if remaining > 0:\n        heappush(soda, (remaining, i))\n\n# Initialize the number of bottles to store the soda\nk = len(soda)\n\n# Initialize the time to pour the soda\nt = 0\n\n# While there are more than one bottle in the list\nwhile len(soda) > 1:\n    # Get the bottle with the least remaining soda\n    (min_soda, min_index) = heappop(soda)\n    \n    # Get the bottle with the most remaining soda\n    (max_soda, max_index) = heappop(soda)\n    \n    # Calculate the amount of soda to pour from the max bottle to the min bottle\n    pour = min(max_soda, b[min_index] - min_soda)\n    \n    # Update the time to pour the soda\n    t += pour\n    \n    # Update the amount of soda in the max bottle\n    max_soda -= pour\n    \n    # If there is remaining soda in the max bottle, add it back to the list\n    if max_soda > 0:\n        heappush(soda, (max_soda, max_index))\n    \n    # If the min bottle is not full, add it back to the list\n    if min_soda + pour < b[min_index]:\n        heappush", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "#!/bin/python3\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\ndef solve(n, m, grid):\n    # Write your code here\n    pass\n\n\nif __name__ == '__main__':\n    fptr = open(os.environ['OUTPUT_PATH'], 'w')\n\n    nm = input().split()\n\n    n = int(nm[0])\n\n    m = int(nm[1])\n\n    grid = []\n\n    for _ in range(n):\n        grid_item = input()\n        grid.append(grid_item)\n\n    result = solve(n, m, grid)\n\n    fptr.write(str(result) + '\\n')\n\n    fptr.close()", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Input\nn, l, v_1, v_2, k = map(int, input().split())\n\n# Calculate the minimum time required\nif k >= n:\n    time = l / v_2\nelse:\n    time = (n // k) * (l / v_2 + (k - 1) / v_1) + (n % k) / v_1\n\n# Output\nprint(time)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n = int(input())\nx = input()\n\n\ndef popcount(x):\n    return bin(x).count(\"1\")\n\n\ndef complexity(x):\n    ans = 0\n    for i in range(n):\n        if x[i] == '0':\n            ans += pow(2, n - i - 1, 1000000007)\n    return ans % 1000000007\n\n\nans = 0\nfor i in range(n):\n    ans += pow(2, i, 1000000007) * complexity(x[i:])\n    ans %= 1000000007\n\nprint(ans)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "\nM = 10 ** 5\n\nn = int(input())\nss = [int(s) for s in input().split()]\n\nprime_factor = {i: set() for i in range(1, M + 1)}\n\nfor p in range(2, M + 1):\n    if prime_factor[p] != set():\n        continue\n    else:\n        for i in range(p, M + 1, p):\n            prime_factor[i].add(p)\n\ncnt = [0] * (M + 1)\n\nfor s in ss:\n    for p in prime_factor[s]:\n        cnt[p] += 1\n\nprint(max(1, max(cnt)))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from itertools import permutations\nfrom math import ceil, log\n\nn, m = t = list(map(int, input().split()))\nl, _ = t = [ceil(log(x, 7.)) if x > 1 else 1 for x in t]\nprint(sum(int(s[:l], 7) < n and int(s[l:], 7) < m for s in map(''.join, permutations(\"0123456\", sum(t)))))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from collections import deque\n\nn, m = map(int, input().split())\n\ngrid = []\n\nfor _ in range(n):\n    grid.append(input())\n\ndef bfs(grid, start, end):\n    queue = deque([start])\n    visited = set([start])\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            x, y = queue.popleft()\n            if (x, y) == end:\n                return steps\n            \n            for dx, dy in [(1, 0), (0, 1)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < len(grid) and 0 <= new_y < len(grid[0]) and grid[new_x][new_y] == '.' and (new_x, new_y) not in visited:\n                    queue.append((new_x, new_y))\n                    visited.add((new_x, new_y))\n                    \n        steps += 1\n        \n    return -1\n\ndef min_witch_cells(grid):\n    start = (0, 0)\n    end = (len(grid) - 1, len(grid[0]) - 1)\n    dist = bfs(grid, start, end)\n    \n    if dist == -1:\n        return -1\n    \n    min_cells = float('inf')\n    \n    for x in range(len(grid)):\n        for y in range(len(grid[0])):\n            if grid[x][y] == '.' and (x, y) != start and (x, y) != end:\n                grid[x] = grid[x][:y] + '#' + grid[x][y+1:]\n                new_dist = bfs(grid, start, end)\n                if new_dist == -1 or new_dist > dist:\n                    min_cells = min(min_cells, 1)\n                grid[x] = grid[x][:y] +", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def f(b, n):\n    if n < b:\n        return n\n    else:\n        return f(b, n // b) + (n % b)\n\nn, s = map(int, input().split())\n\nb = 2\nwhile b <= 10**11:\n    if f(b, n) == s:\n        print(b)\n        break\n    b += 1\nelse:\n    print(-1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n = int(input())\n\na = list(map(int, input().split()))\n\nc = list(map(abs, a))\n\nif len(list(filter(lambda x: x < 0, a))) & 1 and n + 1 & 1:\n\n  print(sum(c) - 2 * min(c))\n\nelse:\n\n  print(sum(c))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "x1,y1=list(map(int,input().split()))\nx2,y2=list(map(int,input().split()))\n\nif x1==x2:\n    print(4+(abs(y2-y1)+1)*2)\nelif y1==y2:\n    print((abs(x2-x1)+1)*2+4)\nelse:\n    print((abs(x2-x1)+1)*2+(abs(y2-y1)+1)*2)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def get_max_nodes(x0, y0, ax, ay, bx, by, xs, ys, t):\n    def get_node(i):\n        x, y = x0, y0\n        while i > 0:\n            x = ax * x + bx\n            y = ay * y + by\n            i -= 1\n        return x, y\n\n    nodes = [(x0, y0)]\n    i = 1\n    while True:\n        x, y = get_node(i)\n        if abs(x - x0) + abs(y - y0) > t:\n            break\n        nodes.append((x, y))\n        i += 1\n\n    visited = set()\n    best = 0\n    def dfs(x, y, time):\n        nonlocal best\n        if (x, y) in visited or time < 0:\n            return\n        visited.add((x, y))\n        if time == 0:\n            return\n        best = max(best, len(visited))\n        for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:\n            if (nx, ny) in nodes:\n                dfs(nx, ny, time - 1)\n        visited.remove((x, y))\n\n    dfs(xs, ys, t)\n    return best\n\nx0, y0, ax, ay, bx, by = map(int, input().split())\nxs, ys, t = map(int, input().split())\nprint(get_max_nodes(x0, y0, ax, ay, bx, by, xs, ys, t))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "x = int(input())\nmass = []\nfor i in range(x):\n    l = list(map(int, input().split()))\n    mass += [l]\nres = [0 for i in range(x)]\nres[0] = int(((mass[0][1] * mass[0][2]) // mass[1][2]) ** 0.5)\nfor i in range(1, x):\n    res[i] = int(mass[0][i] // res[0])\nprint(*res)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Get the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the sum of the elements\nsum_elements = 0\n\n# Calculate the sum of the elements\nfor element in arr:\n    sum_elements += element\n\n# Check if the sum is positive or negative\nif sum_elements > 0:\n    # If the sum is positive, the maximum sum is obtained by changing the sign of the first n elements\n    print(sum_elements - 2 * sum(arr[:n]))\nelse:\n    # If the sum is negative, the maximum sum is obtained by not changing the sign of any element\n    print(sum_elements)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def untangle(wire_sequence):\n    n = len(wire_sequence)\n    # Initialize the number of crossings to 0\n    crossings = 0\n\n    for i in range(n):\n        # If the current wire is '+' and the previous wire is '-',\n        # increment the number of crossings\n        if wire_sequence[i] == '+' and i > 0 and wire_sequence[i-1] == '-':\n            crossings += 1\n\n    # If the number of crossings is odd, the wires cannot be untangled\n    if crossings % 2 == 1:\n        return False\n    else:\n        return True\n\n# Read the input wire sequence\nwire_sequence = input()\n\n# Call the function to determine if the wires can be untangled\ncan_be_untangled = untangle(wire_sequence)\n\n# Print the output\nif can_be_untangled:\n    print(\"Yes\")\nelse:\n    print(\"No\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n,a,d=map(int,input().split())\nprint(368131125*a%10**9*12*10**9+1,368131125*d%10**9*12*10**9)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Function to calculate the number of distinct integers that can be represented using n roman digits exactly\ndef roman_digits(n):\n    # Base cases\n    if n == 1:\n        return 4\n    if n == 2:\n        return 10\n    \n    # Recursive case\n    return roman_digits(n-1) + roman_digits(n-2)\n\n# Main function\nif __name__ == '__main__':\n    # Read the input\n    n = int(input())\n    \n    # Call the function to calculate the number of distinct integers\n    result = roman_digits(n)\n    \n    # Print the result\n    print(result)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "print(max(1, 4 * int(int(input()) * 2 ** 0.5)))\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\n\na = [[] for i in range(5010)]\n\nfor i in range(m):\n\tx, y = map(int, input().split())\n\tif y < x:\n\t\ta[x].append(n - x + y)\n\telse:\n\t\ta[x].append(y - x)\n\n\nfor i in range(1, n + 1):\n\ta[i].sort()\n\nmx = int(-1e9)\n\nfor i in range(1, n + 1):\n\tif len(a[i]):\n\t\tmx = n * (len(a[i]) - 1) + a[i][0]\n\telse:\n\t\tmx = 0\n\t\n\tk = 1\n\tl = i + 1\n\tif l == n + 1:\n\t\tl = 1\n\t\n\twhile l != i:\n\t\tif len(a[l]):\n\t\t\tmx = max(mx, n * (len(a[l]) - 1) + a[l][0] + k)\n\t\t\t\n\t\tk += 1\n\t\tl += 1\n\t\tif l == n + 1:l = 1\n\tprint(mx, end = \" \")\n\nprint()\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\n# TAIWAN NUMBER ONE!!!!!!!!!!!!!!!!!!!\nfrom sys import stdin, stdout\nfrom math import sqrt\nimport math\nimport heapq\nfrom itertools import accumulate\n\nN = int(input())\n\nf = {}\nf['00'] = []\nf['10'] = []\nf['01'] = []\nf['11'] = []\n\nfor i in range(N):\n    s = [x for x in stdin.readline().split()]\n    f[s[0]].append(int(s[1]))\n    \nfor key in f:\n    f[key].sort(reverse=True)\n    \n#print(f)\n\ns_X = sum(f['11'])\n# X >= W\nX = len(f['11'])\nY = len(f['10'])\nZ = len(f['01'])\n\nm = min(Y,Z)\n\n# calculate prefix of '10' and '01'\ns_Y = [0]*len(f['10'])\ns = 0\nfor i in range(len(f['10'])):\n    s += f['10'][i]\n    s_Y[i] = s\ns_Z = [0]*len(f['01'])\ns = 0\nfor i in range(len(f['01'])):\n    s += f['01'][i]\n    s_Z[i] = s\n\n# W = 0 to X\nres = 0\ns = 0\nfor W in range(X+1):\n    # abs(Y-Z) <= X-W\n    if W>len(f['00']):\n        break\n    if W>=1:\n        s += f['00'][W-1]\n    \n    bound = X-W\n    if Y>Z:\n        tmp_Y = min(Y,Z+bound)\n        tmp_Z = Z\n    elif Y==Z:\n        tmp_Y = Y\n        tmp_Z = Z\n    elif Y<Z:\n        tmp_Y = Y\n        tmp_Z = min(Z,Y+bound)\n    \n    # X+W+Y+Z\n    calculate = s_X + s\n    if tmp_Y>0:\n        calculate += s_Y[tmp_Y-1]\n    if tmp_Z>0:\n        calculate += s_Z[tmp_Z-1]\n        \n    res = max(res,calculate)\n    #print(X,tmp_Y,tmp_Z,W,calculate)\n    \nprint(res)\n            \n\n\n    \n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            return\n    c+=aux\n    c1+=1\nprint(\"Yes\")\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "MOD = 10**9 + 7\nN, M = map(int, input().split())\nS = [[N]*(N+1) for i in [0,1,2]]\nT = [[0]*(N+1) for i in [0,1,2]]\n\nC = [0]*(N+1)\nfor i in range(M):\n    l, r, x = map(int, input().split())\n    S[x-1][r] = min(S[x-1][r], l)\n    T[x-1][r] = max(T[x-1][r], l)\n    C[r] = 1\n\nS0, S1, S2 = S\nT0, T1, T2 = T\n\nok = 1\nfor i in range(N+1):\n    if not T2[i] < S1[i] or not T1[i] < S0[i]:\n        ok = 0\n        break\n\nif not ok:\n    print(0)\n    return\n\n\nX = {(0, 0): 3}\nfor b in range(1, N):\n    t2 = T2[b+1]; s1 = S1[b+1]; t1 = T1[b+1]; s0 = S0[b+1]\n    check = lambda r, g: t2 <= r < s1 and t1 <= g < s0\n\n    Z = [0]*(N+1)\n    if C[b+1]:\n        if t1 <= b < s0:\n            for (r, g), v in X.items():\n                if t2 <= g < s1:\n                    # r <- b+1\n                    Z[g] += v\n                if t2 <= r < s1:\n                    # g <- b+1\n                    Z[r] += v\n        X = {(r, g): v for (r, g), v in X.items() if t2 <= r < s1 and t1 <= g < s0}\n    else:\n        Z = [0]*(N+1)\n        for (r, g), v in X.items():\n            # r <- b+1\n            Z[g] += v\n            # g <- b+1\n            Z[r] += v;\n    for z, v in enumerate(Z):\n        if v:\n            X[z, b] = v % MOD\nprint(sum(X.values()) % MOD)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n,l,v1,v2,k=list(map(int,input().split()))\n\nn=(n+k-1)//k\n\na=(v2-v1)/(v1+v2)\n\nt=l/v2/(n-(n-1)*a)\n\nprint(n*t+(n-1)*a*t)\n\n\n\n# Made By Mostafa_Khaled\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def robot_position(a, b, s):\n    # Initialize the robot's position\n    robot_x = 0\n    robot_y = 0\n\n    # Iterate over the commands in the string\n    for command in s:\n        if command == 'U':\n            robot_y += 1\n        elif command == 'D':\n            robot_y -= 1\n        elif command == 'L':\n            robot_x -= 1\n        elif command == 'R':\n            robot_x += 1\n\n    # Check if the robot's position matches the target position\n    if robot_x == a and robot_y == b:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read the input\na, b = map(int, input().split())\ns = input()\n\n# Check the robot's position\nresult = robot_position(a, b, s)\n\n# Print the result\nprint(result)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "input()\nsqrs = set()\nx = 0\nwhile x ** 2 <= 10 ** 6:\n    sqrs.add(x ** 2)\n    x += 1\n\nprint(max([x for x in map(int, input().split()) if x not in sqrs]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from collections import deque\n\n\ndef check_bfs_order(n, edges, order):\n    # Create an adjacency list to store the edges.\n    graph = [[] for _ in range(n + 1)]\n\n    # Add the edges to the adjacency list.\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    # Initialize a queue and mark all nodes as unvisited.\n    queue = deque([1])\n    visited = [False] * (n + 1)\n\n    # Initialize an index to keep track of the order.\n    index = 0\n\n    # Perform the BFS traversal.\n    while queue:\n        # Extract the current vertex from the queue.\n        current = queue.popleft()\n\n        # Check if the current vertex matches the next element in the order.\n        if current != order[index]:\n            return False\n\n        # Increment the index.\n        index += 1\n\n        # Mark the current vertex as visited.\n        visited[current] = True\n\n        # Iterate through all neighbors of the current vertex.\n        for neighbor in graph[current]:\n            # If the neighbor is not visited, add it to the queue.\n            if not visited[neighbor]:\n                queue.append(neighbor)\n\n    # Check if all vertices have been visited.\n    if index != n:\n        return False\n\n    return True\n\n\n# Main function to run the program.\ndef main():\n    # Read the number of nodes in the tree.\n    n = int(input())\n\n    # Initialize the edges list.\n    edges = []\n\n    # Read the edges of the tree.\n    for _ in range(n - 1):\n        x, y = map(int, input().split())\n        edges.append([x, y])\n\n    # Read the BFS order.\n    order = list(map(int, input().split()))\n\n    # Check if the order is valid.\n    if check_bfs_order(n, edges", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef get_polynomials(n):\n    if n < 1:\n        return -1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                A = [1] + [0] * (i - 1) + [k]\n                B = [1] + [0] * (j - 1)\n                steps = 0\n                while True:\n                    steps += 1\n                    if steps > n:\n                        break\n                    R = [x % 2 for x in A]\n                    while R and R[-1] == 0:\n                        R.pop()\n                    if not R:\n                        break\n                    A = B\n                    B = R\n                if steps == n:\n                    return A, B\n    return -1\n\ndef main():\n    n = int(input())\n    result = get_polynomials(n)\n    if result == -1:\n        print(-1)\n    else:\n        A, B = result\n        print(len(A) - 1)\n        print(*A)\n        print(len(B) - 1)\n        print(*B)\n\nif __name__ == '__main__':\n    main()", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\nm = min(a)\nM = max(a)\ncount = 0\nfor el in a:\n    if el != m and el != M:\n        count += 1\nprint(count)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "#in the name of god\n#Mr_Rubick\na,b,c,l=list(map(int, input().split()))\ncnt=(l+3)*(l+2)*(l+1)//3\nfor i in (a,b,c):\n    s=2*i-a-b-c\n    for x in range(max(0,-s),l+1):\n        m = min(s+x,l-x)\n        cnt-=(m+1)*(m+2)\nprint(cnt//2)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "import math\n\nw, h, alpha = map(int, input().split())\n\nalpha = alpha * math.pi / 180\n\nx = w / 2 * math.cos(alpha) + h / 2 * math.sin(alpha)\ny = w / 2 * math.sin(alpha) - h / 2 * math.cos(alpha)\n\narea = (w * x + h * y) / 2\n\nprint(area)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "a, b, c = map(int, input().split(' '))\narray = [[i for i in input()] for j in range(a)]\np = []\nx = 0\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            p = [(i, j)]\n            x += 1\n\nvisited = [[False for _ in range(b)] for i in range(a)]\ndef ok(i, j):\n    if 0 <= i <= a-1 and 0 <= j <= b-1:\n        if array[i][j] == '.':\n            return True\n    return False\n\nsa = 0\nwhile sa < x-c:\n    i, j = p[-1]\n    p.pop()\n    #print(i,j,sa)\n    if not visited[i][j]:\n        if ok(i, j-1):\n            if not visited[i][j-1]:\n                p.append((i, j-1))\n        if ok(i, j+1):\n            if not visited[i][j+1]:\n                p.append((i, j+1))\n        if ok(i+1, j):\n            if not visited[i+1][j]:\n                p.append((i+1, j))\n        if ok(i-1, j):\n            if not visited[i-1][j]:\n                p.append((i-1, j))\n        visited[i][j] = True\n        sa+=1\n\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.' and not visited[i][j]:\n            array[i][j] = 'X'\n\nfor each in [''.join(i) for i in array]:\n    print(each)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "from heapq import heappush, heappop\n\nn, m = [int(i) for i in input().split()]\nfood = 0\ntummy = []\ndish = [ -int(i) for i in input().split()]\nfor i in range(1, min(m, n+1)):\n    while tummy and -tummy[0] >= m- i:\n        heappop(tummy)\n    if max(-dish[i-1], i) < m:\n        heappush(tummy, dish[i-1] + i)\n    food = max(len(tummy), food)\nprint(food)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def solve_duel(n, k, s):\n    def flip(i, j):\n        return s[:i] + s[i:j].replace('1', '2').replace('0', '1').replace('2', '0') + s[j:]\n\n    if n % k == 0:\n        return \"once again\"\n\n    for i in range(n):\n        for j in range(i, n, k):\n            if (j - i + 1) % k == 0:\n                s = flip(i, j + 1)\n                if s.count('0') == 0 or s.count('1') == 0:\n                    return \"tokitsukaze\"\n\n    return \"quailty\"\n\nn, k = map(int, input().split())\ns = input()\nprint(solve_duel(n, k, s))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Define a function to calculate the minimum fuel mass\ndef min_fuel(n, m, a, b):\n    # Initialize the fuel mass to 0\n    fuel = 0\n    \n    # Iterate through each planet\n    for i in range(n-1):\n        # Calculate the amount of fuel required for take-off\n        takeoff = m * a[i]\n        # Calculate the amount of fuel required for landing\n        landing = m * b[i]\n        \n        # If the fuel is greater than the takeoff, subtract the takeoff from the fuel\n        if fuel >= takeoff:\n            fuel -= takeoff\n        # Otherwise, add the takeoff to the fuel\n        else:\n            fuel += takeoff\n        \n        # If the fuel is greater than the landing, subtract the landing from the fuel\n        if fuel >= landing:\n            fuel -= landing\n        # Otherwise, add the landing to the fuel\n        else:\n            fuel += landing\n            \n    # If the fuel is greater than the payload, subtract the payload from the fuel\n    if fuel >= m:\n        fuel -= m\n    # Otherwise, add the payload to the fuel\n    else:\n        fuel += m\n        \n    # If the fuel is negative, return -1\n    if fuel < 0:\n        return -1\n    # Otherwise, return the fuel\n    else:\n        return fuel\n\n# Read input from stdin\nn = int(input())\nm = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Call the function to calculate the minimum fuel mass\nresult = min_fuel(n, m, a, b)\n\n# Print the result\nprint(result)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "a=[0,4,10,20,35,56,83,116,155,198,244]\nb=292\nn=int(input())\nif n<=10:\n\tprint(a[n])\nelse:\n\tprint(b+(n-11)*49)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n, k = map(int, input().split())\nm = 0x3b9aca07\nr = 0\np = pow(2, n, m)\na = [1] + [0] * k\nfor i in range(k):\n    for j in range(i, -1, -1):\n        a[j + 1] += a[j]\n        a[j] = a[j] * j % m\nfor i in range(k + 1):\n    r += p * a[i]\n    p = p * 500000004 * (n - i) % m\nprint(r % m)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\nt = [0] * 2 * n\ns = 0\nfor i in range(n):\n    d = a[i] - i - 1\n    s += abs(d)\n    if d > 0: t[d] += 1\np = sum(t)\nr = (s, 0)\nfor i in range(1, n):\n    d = a[n - i] - 1\n    s += d - p << 1\n    t[d + i] += d > 0\n    p += (d > 0) - t[i]\n    if s < r[0]: r = (s, i)\nprint(*r)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def main():\n    def center(xx):\n        return sum(xx[::2]) * .25, sum(xx[1::2]) * .25\n\n    aa = list(map(float, input().split()))\n    bb = list(map(float, input().split()))\n    x, y = center(aa)\n    for i in range(0, 8, 2):\n        aa[i] -= x\n        bb[i] -= x\n        aa[i + 1] -= y\n        bb[i + 1] -= y\n    x, y = center(bb)\n    if x < 0.:\n        for i in range(0, 8, 2):\n            bb[i] *= -1.\n    if y < 0.:\n        for i in range(1, 8, 2):\n            bb[i] *= -1.\n    x, y = max(aa[i:i + 2] for i in range(0, 8, 2))\n    for i in range(0, 8, 2):\n        bb[i] -= x\n        bb[i + 1] -= y\n    [x1, y1], [x2, y2] = sorted(bb[i:i + 2] for i in range(0, 8, 2))[:2]\n    print(('NO', 'YES')[x1 <= 0 and x1 + y1 <= 0. and y2 <= 0. and x2 + y2 <= 0.])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "a, b = list(map(int, input().split()))\nif a < b:\n    print(-1)\nelif a == b:\n    print(a)\nelse:\n    ku = (a - b) // (2 * b)\n    kd = (a + b) // (2 * b)\n    xd = (a + b) / (2 * kd)\n    if ku == 0:\n        print(xd)\n    else:\n        xu = (a - b) / (2 * ku)\n        print(min(xu, xd))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "#This code solves the given question using Python3.\n\n#Importing necessary libraries\nfrom math import log2, floor\n\n#Defining the function to calculate the required number of perfect sets\ndef number_of_perfect_sets(k):\n    #Initializing the answer variable\n    answer = 0\n    \n    #Iterating over all possible set sizes\n    for set_size in range(1, floor(log2(k)) + 1):\n        #Checking if the current set size is a power of 2\n        if set_size & (set_size - 1) == 0:\n            #If the set size is a power of 2, we can create 2^(set_size - 1) perfect sets\n            answer += (1 << (set_size - 1))\n        #Otherwise, we can create 2^(set_size - 1) - 1 perfect sets\n        else:\n            answer += (1 << (set_size - 1)) - 1\n    \n    #Returning the answer modulo 1000000007 (10^9 + 7)\n    return answer % 1000000007\n\n#Taking the input for k\nk = int(input())\n\n#Printing the required number of perfect sets\nprint(number_of_perfect_sets(k))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# \u3053\u306e\u89e3\u6cd5\u306f\u5618\u3092\u542b\u3080\n\nfrom itertools import groupby\nH, W = list(map(int, input().split()))\nS_ = [\"\" for _ in range(W)]\nT_ = []\nfor _ in range(H):\n    s = input()\n    T_.append(s)\n    for i, c in enumerate(s):\n        S_[i] += c\nT = [sorted(t) for t in T_]\nS = [sorted(s) for s in S_]\ncnt = 0\nfor _, g in groupby(sorted(T)):\n    if len(list(g))%2:\n        cnt += 1\nif H%2 < cnt:\n    print(\"NO\")\n    return\ncnt = 0\nfor _, g in groupby(sorted(S)):\n    if len(list(g))%2:\n        cnt += 1\nif W%2 < cnt:\n    print(\"NO\")\n    return\nif W%2 or H%2:\n    print(\"YES\")\n    return\nT1 = []\nT2 = []\nfor i, (_, t) in enumerate(sorted(zip(T, T_))):\n    if i%2:\n        T1.append(t)\n    else:\n        T2.append(t)\nT_p = T1 + T2[::-1]\nS_pp = [\"\" for _ in range(W)]\nfor t in T_p:\n    for i, c in enumerate(t):\n        S_pp[i] += c\nS1 = []\nS2 = []\nfor i, (_, s) in enumerate(sorted(zip(S, S_pp))):\n    if i%2:\n        S1.append(s)\n    else:\n        S2.append(s)\nS_p = S1 + S2[::-1]\nfor s1, s2 in zip(S_p, S_p[::-1]):\n    for c1, c2 in zip(s1, s2[::-1]):\n        if c1!=c2:\n            print(\"NO\")\n            return\nprint(\"YES\")\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "#!/usr/bin/env python3\n\nimport sys\n\ndef solve(n, m, k, flights):\n    dp = [[0 for _ in range(k)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(k):\n            min_cost = sys.maxsize\n            for flight in flights:\n                if flight[1] == i and flight[0] + j < k and dp[flight[2]][flight[0] + j] + flight[3] < min_cost:\n                    min_cost = dp[flight[2]][flight[0] + j] + flight[3]\n            dp[i][j] = min_cost\n\n    min_cost = sys.maxsize\n    for i in range(n + 1):\n        if dp[i][k - 1] < min_cost:\n            min_cost = dp[i][k - 1]\n\n    return -1 if min_cost == sys.maxsize else min_cost\n\nif __name__ == '__main__':\n    n, m, k = map(int, input().split())\n    flights = []\n    for _ in range(m):\n        d, f, t, c = map(int, input().split())\n        flights.append((d, f, t, c))\n\n    cost = solve(n, m, k, flights)\n    print(cost)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Input:\ns = input()\nt = input()\n\n# Find the number of 0s and 1s in s.\nn0 = s.count('0')\nn1 = s.count('1')\n\n# Check if the number of 0s and 1s in s is not the same as in t.\nif n0 != t.count('0') or n1 != t.count('1'):\n    print('No solution')\n\n# Otherwise, find the longest common substring of s and t.\nelse:\n    # Initialize the longest common substring to an empty string.\n    lcs = ''\n\n    # Iterate through all possible substrings of s.\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            # Check if the current substring is a common substring of s and t.\n            if s[i:j] in t and len(s[i:j]) > len(lcs):\n                lcs = s[i:j]\n\n    # Check if the longest common substring is not found.\n    if lcs == '':\n        print('No solution')\n\n    # Otherwise, rearrange the schedule according to the longest common substring.\n    else:\n        schedule = ''\n\n        # Repeat the longest common substring until the number of 0s and 1s matches.\n        while n0 > 0 or n1 > 0:\n            for c in lcs:\n                schedule += c\n                if c == '0':\n                    n0 -= 1\n                else:\n                    n1 -= 1\n\n        print(schedule)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Input:\nA, B = map(int, input().split())\n\n# Output:\nprint(3, 3)\nprint('##.')\nprint('..#')\nprint('#.#')", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "scan=lambda:list(map(int,input().split()))\nx1,y1,x2,y2=scan()\nvmx,t=scan()\nvx,vy=scan()\nwx,wy=scan()\nlb,ub,EPS=0,1e15,1e-8\nwhile ub-lb>EPS:\n\tmid=(lb+ub)/2\n\txx,yy=(vx*mid,vy*mid) if t-mid>EPS else (vx*t+wx*(mid-t),vy*t+wy*(mid-t))\n\tif vmx*mid-((x2-x1-xx)**2+(y2-y1-yy)**2)**.5>EPS:ub=mid\n\telse:lb=mid\nprint(\"%.8f\"%ub)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "def main(a, b, l, r):\n\n    \n\n    qL = (l - 1) // (2 * a + 2 * b)\n\n    rL = (l - 1) % (2 * a + 2 * b) + 1\n\n    \n\n    qR = (r - 1) // (2 * a + 2 * b)\n\n    rR = (r - 1) % (2 * a + 2 * b) + 1\n\n    #print(qL, qR, rL, rR)\n\n    if qL == qR:\n\n        #In b segment\n\n        if a < rL <= a + b and a < rR <= a + b:\n\n            return 1\n\n        if 2 * a + b < rL and 2 * a + b < rR:\n\n            return 1\n\n        #In a segment\n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return rR - rL + 1\n\n        if a + b < rL <= 2 * a + b and a + b < rR <= 2 * a + b:\n\n            return rR - rL + 1\n\n        #In a + b segment\n\n        if 1 <= rL <= a + b and 1 <= rR <= a + b:\n\n            return a - rL + 1\n\n        if a + b < rL and a + b < rR:\n\n            return (2 * a + b) - rL + 1\n\n        if a < rL <= a + b and a + b < rR <= 2 * a + b:\n\n            return 1 + rR - (a + b)\n\n        if a < rL <= a + b and 2 * a + b < rR:\n\n            return 1 + a\n\n        if 1 <= rL <= a and a + b < rR <= 2 * a + b:\n\n            ans = a - rL + 1 + max(rR - (a + b + b), 0) + min(b, rR) - max(min(rR, b) - rL + 1, 0)\n\n            return ans\n\n        if 1 <= rL <= a and 2 * a + b < rR:\n\n            return a - rL + 1 + a - max(b - rL + 1, 0)\n\n    elif qL == qR - 1:\n\n        #abababab\n\n        newL = qL * (2 * a + 2 * b) + 1\n\n        newR = (qR + 1) * (2 * a + 2 * b)\n\n        \n\n        if 1 <= rL <= a + b and a + b + 1 <= rR:\n\n            return a + max(a - b, 0) + int(a <= b) \n\n            \n\n        if a + b + 1 <= rL <= 2 * (a + b) and (2 * a + 2 * b) + 1 <= rR <= a + b:\n\n            return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n        if 1 <= rL <= a and 1 <= rR <= a:\n\n            return a + max(a - b, 0) + int(a <= b) + rR - max(rR - rL + 1, 0)\n\n        if 1 <= rL <= a and a + 1 <= rR <= a + b:\n\n            return a + max(a - b, 0) + int(a <= b)\n\n        \n\n        if a + 1 <= rL <= a + b and 1 <= rR <= a:\n\n            return 1 + a\n\n        if a + 1 <= rL <= a + b and a + 1 <= rR <= a + b:\n\n            return 1 + a + max(a - b, 0)\n\n        \n\n        return main(a, b, l - (a + b), r - (a + b))\n\n        \n\n    else:\n\n        return a + max(a - b, 0) + int(a <= b) # + main(a, b, l, (qL + 1) * (2 * a + 2 * b)) + main(a, b, qR * (2 * a + 2 * b) + 1, r)\n\n\n\na, b, l, r = [int(item) for item in input().split()]\n\n\n\nprint(main(a, b, l, r))\n\n\n\n# Made By Mostafa_Khaled\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "# Input the size of the permutation\nn = int(input())\n\n# Check if the permutation size is odd or even\nif n % 2 == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    # For odd permutation size, print the swaps in reverse order\n    for i in range(n-1, 0, -1):\n        print(i, i-1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\CodeLlama-70b-Instruct-hf-apps_competition_207.jsonl"}
{"code": "n = int(input())\n\nif n % 2 == 0:\n    print(-1)\nelse:\n    print(\" \".join(map(str, range(n))))\n    print(\" \".join(map(str, range(n))))\n    print(\" \".join(map(str, [2*x % n for x in range(n)])))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import math\n\nT = int(input())\n\n#lets = 'abcdefghijklmnopqrstuvwxyz'\n#key = {lets[i]:i for i in range(26)}\n\nfor t in range(T):\n  n = int(input())\n  #x1,y1,x2,y2 = map(int,input().split())\n  #a = list(map(int,input().split()))\n  #a = list(input())\n  a = input()\n  d = False\n  if a.count('>') == 0:\n    print(n)\n    continue\n  if a.count('<') == 0:\n    print(n)\n    continue\n  ans = 0\n  for i in range(n):\n    if a[i]=='-' or a[i-1]=='-':\n      ans+=1\n  print(ans)\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import io, os\n#input = io.StringIO(os.read(0, os.fstat(0).st_size).decode()).readline\n\nn = int(input())\n\na = list(map(int, input().split()))\n\nb = list(map(int, input().split()))\n\nf = True\nif 1 in b:\n\t\n\tj = b.index(1)\n\t\n\tfor i in range(n - j):\n\t\td = i + 1 - b[j + i]\n\t\tif d != 0:\n\t\t\tbreak\n\telse:\n\t\ts = -2\n\t\tfor k in range(j):\n\t\t\tif b[k] != 0 and b[k] - k <= n - (j - 1):\n\t\t\t\tbreak\n\t\telse:\n\t\t\tprint(j)\n\t\t\tf = False\n\n\n\nif f:\n\ts = -2\n\tfor k in range(n):\n\t\tif b[k] != 0:\n\t\t\ts = max(s, k - b[k])\n\tprint(s + n + 2)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n,a,b = map(int,input().split())\nif not (a+b-1 <= n <= a*b):\n  print(-1)\n  return\nn -= a\nl = list()\nfor i in range(b,a*b+1,b):\n  t = min(n,b-1)\n  l += [i-j for j in range(t+1)]\n  n -= t\nd = dict()\ng = sorted(l)\nfor i,x in enumerate(g,1):\n  d[x] = i\nl = list(map(lambda x:d[x], l))\nprint(*l)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "#coding utf-8\n\ns=input().split();\nn=int(s[0]);k=int(s[1]);x=int(s[2]);\na=[[]]\ns=input().split();\nfor i in range(n):\n\ta[0].append(int(s[i]));\n\na[0].sort()\nfor i in range(1,k+1):\n\ta.append([a[i-1][t]^(x*((t+1)%2)) for t in range(len(a[i-1]))])\n\ta[i].sort()\n\tfor t in range(i):\n\t\tif a[i]==a[t]:\n\t\t\tflag=True\n\t\t\tbreak\n\tif(t!=i-1):break\n\nif(k==0):tag=0\nelif(i==k):tag=k\nelse:tag=(k-i+1)%(t-i)+i-1\n\nprint(max(a[tag]),min(a[tag]))\n\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "\nM = 10 ** 5\n\nn = int(input())\nss = [int(s) for s in input().split()]\n\nprime_factor = {i: set() for i in range(1, M + 1)}\n\nfor p in range(2, M + 1):\n    if prime_factor[p] != set():\n        continue\n    else:\n        for i in range(p, M + 1, p):\n            prime_factor[i].add(p)\n\ncnt = [0] * (M + 1)\n\nfor s in ss:\n    for p in prime_factor[s]:\n        cnt[p] += 1\n\nprint(max(1, max(cnt)))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import math\n\nw, h, alpha = map(int, input().split())\nalpha = float(alpha)\n\narea = w * h * math.sin(math.radians(alpha)) / 2\n\nprint(area)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import numpy as np\n\nn, m = map(int, input().split())\nvolcano_loc = np.array([[int(x) for x in input().split()] for _ in range(m)])\n\nif not volcano_loc.size:\n    print(-1)\n\ngrid_size = np.sqrt(n)\ndistance = np.inf * np.ones((int(grid_size), int(grid_size)))\ndistance[0][0] = 0\n\ndirection = np.array([[1, 0], [0, 1]])\n\nfor r in range(grid_size):\n    for c in range(grid_size):\n        if distance[r][c] != np.inf and (r, c) not in volcano_loc.T:\n            for d in direction:\n                new_r, new_c = r + d[0], c + d[1]\n                if 0 <= new_r < grid_size and 0 <= new_c < grid_size and distance[new_r][new_c] == np.inf:\n                    distance[new_r][new_c] = distance[r][c] + 1\n\nmin_time = distance[grid_size - 1][grid_size - 1]\n\nif min_time != np.inf:\n    print(min_time)\nelse:\n    print(-1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, d, e = map(int, input().split())\n\n# Calculate the exchange rate\nusd_rate = d\neuro_rate = e\n\n# Calculate the minimum number of rubles\nmin_rubles = n // usd_rate + n % usd_rate * euro_rate // euro_rate\n\n# Print the minimum number of rubles\nprint(min_rubles)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the number of students that need to be persuaded\npersuaded = 0\nfor i in range(n):\n    if a[i] == 1 or a[i] == 2:\n        persuaded += 1\n\n# If no sequence of swapping seats leads to the desired result, print -1\nif persuaded == 0:\n    print(-1)\n\n# Otherwise, print the smallest number of people to persuade\nelse:\n    print(persuaded)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "a=[0,4,10,20,35,56,83,116,155,198,244]\nb=292\nn=int(input())\nif n<=10:\n\tprint(a[n])\nelse:\n\tprint(b+(n-11)*49)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, t, k, d = map(int, input().split())\n\nif (n - 1) * t <= k * t:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\nprint(min((n-1) * m, (n-1) // 3 + m // 3))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\ns = input().lower()\nt = input().lower()\n\nif '*' in s:\n    s = s.replace('*', '')\n\nif t.find(s) != -1:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "read = lambda: map(int, input().split())\nn, k, p = read()\na, b = sorted(read()), sorted(read())\nprint(min(max(abs(b[i + d] - a[i]) + abs(b[i + d] - p) for i in range(n)) for d in range(k - n + 1)))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, k = map(int, input().split())\nm = 0x3b9aca07\nr = 0\np = pow(2, n, m)\na = [1] + [0] * k\nfor i in range(k):\n    for j in range(i, -1, -1):\n        a[j + 1] += a[j]\n        a[j] = a[j] * j % m\nfor i in range(k + 1):\n    r += p * a[i]\n    p = p * 500000004 * (n - i) % m\nprint(r % m)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, t = map(int, input().split())\n\nm = 0\nfor i in range(n + 1):\n    if t - i * (i - 1) // 2 <= 0:\n        m += 1\n\nprint(m)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nedge = [tuple(map(int,input().split())) for i in range(M)]\n\nG = Dinic(2*N+2)\nres = 0\nfor i in range(1,N+1):\n    if B[i-1]>0:\n        res += B[i-1]\n        G.add_edge(0,i,B[i-1])\n        G.add_edge(0,N+i,B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    else:\n        G.add_edge(i,2*N+1,-B[i-1])\n        res += -B[i-1]\n        G.add_edge(N+i,2*N+1,-B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    G.add_edge(i,N+i,10**15)\n\nfor u,v in edge:\n    G.add_edge(u,N+v,10**15)\n    G.add_edge(v,N+u,10**15)\n\nres -= G.flow(0,2*N+1)\n\nprint(res)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "R = lambda: map(int, input().split())\nmod = 10 ** 9 + 7\nmaxn = 1001\nc = [[0 for j in range(maxn)] for i in range(maxn)]\nfor i in range(maxn):\n    c[i][0] = 1\nfor i in range(1, maxn):\n    for j in range(i + 1):\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\narr = list(map(int, input()))\nk = int(input())\nif k == 0:\n    print(1 if arr.count(1) else 0)\n    return\nops = [0] * (maxn + 1)\nans = 0\nfor i in range(2, maxn):\n    cnt = bin(i).count('1')\n    ops[i] = ops[cnt] + 1\nfor i in range(1, maxn):\n    if ops[i] == k - 1:\n        oc = i\n        for j, x in enumerate(arr):\n            if x and oc >= 0:\n                ans = (ans + c[len(arr) - j - 1][oc]) % mod\n                oc -= 1\n        ans = (ans + 1) % mod if arr.count(1) == i else ans\nif k == 1:\n    ans = (ans + mod - 1) % mod\nprint(ans)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "MOD=int(1e9+7)\nn,k=list(map(int,input().split()))\nif k<2:p=n-(1-k)\nelse:\n\tt=1\n\ta=k\n\twhile a!=1:\n\t\ta=a*k%n\n\t\tt+=1\n\tp=(n-1)//t\nprint(pow(n,p,MOD))\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "a, b = input().split()\na_l, b_l = len(a.split()) // 2, len(b.split()) // 2\n\na_1, a_2 = a.split()\nb_1, b_2 = b.split()\n\nif (a_1 == b_1 and a_2 == b_2) or (a_1 == b_2 and a_2 == b_1):\n  print(\"YES\")\nelse:\n  print(\"NO\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\ns = list(map(int, input().split()))\n\ns.sort()\n\ng = 1\nfor i in s:\n    g = gcd(g, i)\n\nprint(len(s) - g + 1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "from sys import stdin, stdout\nimport math, collections\nmod = 10**9+7\n\ndef isPower(n):\n    if (n <= 1):\n        return True\n    for x in range(2, (int)(math.sqrt(n)) + 1):\n        p = x\n        while (p <= n):\n            p = p * x\n            if (p == n):\n                return True\n\n    return False\nn = int(input())\narr = [0,1,2,1,4,3,2,1,5,6,2,1,8,7,5,9,8,7,3,4,7,4,2,1,10,9,3,6,11,12]\nans = arr[int(math.log(n, 2))]\ns = int(math.log(n, 2))\nfor i in range(3, int(n**0.5)+1):\n    if not isPower(i):\n        ans^=arr[int(math.log(n, i))]\n        s+=int(math.log(n, i))\nans^=((n-s)%2)\nprint(\"Vasya\" if ans else \"Petya\")", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "a,b,h,w,n=list(map(int,input().strip().split(' ')))\nif a>b:\n    a,b=b,a\n    \nfactor=list(map(int,input().strip().split(' ')))\nfactor=sorted(factor)[::-1]\n#print(factor)\ndef findout(a,b,h,w,factor):\n    possible=set()\n    for i in range(len(factor)):\n        temp=set()\n        if i==0:\n            temp.add((factor[0],1))\n            temp.add((1,factor[0]))\n            possible=temp\n            for X in temp:\n                f1,f2=X\n                if f1*h>=a and f2*w>=b:\n                    return i+1\n            \n            \n        else:\n            for X in possible:\n                c1,c2=X\n                if c1*h<=a:\n                    temp.add((c1*factor[i],c2))\n                    if c1*factor[i]*h>=a and c2*w>=b:\n                        return i+1\n                    \n                    \n                    \n                if c2*w<=b:    \n                    temp.add((c1,c2*factor[i]))\n                    if c1*h>=a and c2*w*factor[i]>=b:\n                        return i+1\n            possible=temp\n    return 10**9+1\n\nif (h>=a and w>=b) or (h>=b and w>=a):\n    print(0)\nelse:\n    ans=min(findout(a,b,h,w,factor),findout(a,b,w,h,factor))\n    if ans!=10**9+1:\n        print(ans)\n    else:\n        print(-1)\n                \n                \n            \n            \n            \n            \n            \n            \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import math\nimport sys\ninput=sys.stdin.readline\n \np=(10**9)+7\npri=p\nfac=[1 for i in range((10**6)+1)]\nfor i in range(2,len(fac)):\n    fac[i]=(fac[i-1]*(i%pri))%pri\ndef modi(x):\n    return (pow(x,p-2,p))%p;\n    \ndef ncr(n,r):\n    x=(fac[n]*((modi(fac[r])%p)*(modi(fac[n-r])%p))%p)%p\n    return x;\n\ndef prime(x):\n    ans=[]\n    while(x%2==0):\n        x=x//2\n        ans.append(2)\n    for i in range(3,int(math.sqrt(x))+1,2):\n        while(x%i==0):\n            ans.append(i)\n            x=x//i\n    if(x>2):\n        ans.append(x)\n\n    return ans;\n\n\n\nn=int(input())\n\nz=list(map(int,input().split()))\nans=[]\nfor i in range(len(z)):\n    m=prime(z[i])\n    ans.extend(m)\n  \nans.sort()\nif(ans.count(1)==len(ans)):\n    print(1)\n    return\ncn=[]\ncount=1\nfor i in range(1,len(ans)):\n    if(ans[i]==ans[i-1]):\n        count+=1\n    else:\n        cn.append(count)\n        count=1\ncn.append(count)\nal=1\n\nfor i in range(len(cn)):\n    al=al*ncr(n+cn[i]-1,n-1)\n    al%=pri\nprint(al)\n    \n    \n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "# \u3053\u306e\u89e3\u6cd5\u306f\u5618\u3092\u542b\u3080\n\nfrom itertools import groupby\nH, W = list(map(int, input().split()))\nS_ = [\"\" for _ in range(W)]\nT_ = []\nfor _ in range(H):\n    s = input()\n    T_.append(s)\n    for i, c in enumerate(s):\n        S_[i] += c\nT = [sorted(t) for t in T_]\nS = [sorted(s) for s in S_]\ncnt = 0\nfor _, g in groupby(sorted(T)):\n    if len(list(g))%2:\n        cnt += 1\nif H%2 < cnt:\n    print(\"NO\")\n    return\ncnt = 0\nfor _, g in groupby(sorted(S)):\n    if len(list(g))%2:\n        cnt += 1\nif W%2 < cnt:\n    print(\"NO\")\n    return\nif W%2 or H%2:\n    print(\"YES\")\n    return\nT1 = []\nT2 = []\nfor i, (_, t) in enumerate(sorted(zip(T, T_))):\n    if i%2:\n        T1.append(t)\n    else:\n        T2.append(t)\nT_p = T1 + T2[::-1]\nS_pp = [\"\" for _ in range(W)]\nfor t in T_p:\n    for i, c in enumerate(t):\n        S_pp[i] += c\nS1 = []\nS2 = []\nfor i, (_, s) in enumerate(sorted(zip(S, S_pp))):\n    if i%2:\n        S1.append(s)\n    else:\n        S2.append(s)\nS_p = S1 + S2[::-1]\nfor s1, s2 in zip(S_p, S_p[::-1]):\n    for c1, c2 in zip(s1, s2[::-1]):\n        if c1!=c2:\n            print(\"NO\")\n            return\nprint(\"YES\")\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\nx = list(map(int, input().split()))\n\nx.sort()\npiles = 1\n\nfor i in range(len(x)):\n    x[i] -= piles\n\npiles += sum(x)\n\nprint(piles)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "#!/usr/bin/env python3\n\nimport re\n\ntry:\n    while True:\n        s = input()\n        n = int(s[s.rfind(' '):])\n        pos = s.count('+') + 1\n        neg = s.count('-')\n        if n * pos - neg < n or pos - n * neg > n:\n            print(\"Impossible\")\n        else:\n            print(\"Possible\")\n            need = n - (pos - neg)\n            prev = '+'\n            first = True\n            for m in re.finditer(r\"[+-]\", s):\n                if first:\n                    first = False\n                else:\n                    print(prev, end=' ')\n\n                if prev == '+' and need > 0:\n                    x = min(need + 1, n)\n                    need -= x - 1\n                elif prev == '-' and need < 0:\n                    x = min(-need + 1, n)\n                    need += x - 1\n                else:\n                    x = 1\n\n                print(x, end=' ')\n                prev = m.group()\n\n            if not first:\n                print(prev, end=' ')\n\n            if prev == '+' and need > 0:\n                x = min(need + 1, n)\n                need -= x - 1\n            elif prev == '-' and need < 0:\n                x = min(-need + 1, n)\n                need += x - 1\n            else:\n                x = 1\n\n            print(x, '=', n)\n\nexcept EOFError:\n    pass\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "H, W = map(int, input().split())\n\na = []\nfor _ in range(H):\n    a.append([input().strip() for _ in range(W)])\n\nS, T = None, None\nfor i in range(H):\n    for j in range(W):\n        if a[i][j] == \"S\":\n            S = (i, j)\n        elif a[i][j] == \"T\":\n            T = (i, j)\n\nleaves_to_remove = 0\nif S and T:\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == \"o\" and (i, j) != S and (i, j) != T:\n                leaves_to_remove += 1\n\n    print(leaves_to_remove)\n    print(\"Remove the following leaves:\")\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == \"o\" and (i, j) != S and (i, j) != T:\n                print((i, j))\nelse:\n    print(-1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "MOD = 10**9 + 7\nN, M = map(int, input().split())\nS = [[N]*(N+1) for i in [0,1,2]]\nT = [[0]*(N+1) for i in [0,1,2]]\n\nC = [0]*(N+1)\nfor i in range(M):\n    l, r, x = map(int, input().split())\n    S[x-1][r] = min(S[x-1][r], l)\n    T[x-1][r] = max(T[x-1][r], l)\n    C[r] = 1\n\nS0, S1, S2 = S\nT0, T1, T2 = T\n\nok = 1\nfor i in range(N+1):\n    if not T2[i] < S1[i] or not T1[i] < S0[i]:\n        ok = 0\n        break\n\nif not ok:\n    print(0)\n    return\n\n\nX = {(0, 0): 3}\nfor b in range(1, N):\n    t2 = T2[b+1]; s1 = S1[b+1]; t1 = T1[b+1]; s0 = S0[b+1]\n    check = lambda r, g: t2 <= r < s1 and t1 <= g < s0\n\n    Z = [0]*(N+1)\n    if C[b+1]:\n        if t1 <= b < s0:\n            for (r, g), v in X.items():\n                if t2 <= g < s1:\n                    # r <- b+1\n                    Z[g] += v\n                if t2 <= r < s1:\n                    # g <- b+1\n                    Z[r] += v\n        X = {(r, g): v for (r, g), v in X.items() if t2 <= r < s1 and t1 <= g < s0}\n    else:\n        Z = [0]*(N+1)\n        for (r, g), v in X.items():\n            # r <- b+1\n            Z[g] += v\n            # g <- b+1\n            Z[r] += v;\n    for z, v in enumerate(Z):\n        if v:\n            X[z, b] = v % MOD\nprint(sum(X.values()) % MOD)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "def parse_rebus(rebus):\n    n = int(rebus.split(\"=\")[-1])\n    nums = rebus.split(\"=\")\n    nums.pop()\n    nums = [int(x) for x in nums]\n\n    # Check if the rebus has a solution\n    if not is_valid(nums, n):\n        return \"Impossible\"\n\n    # Find a valid rebus\n    res = find_solution(nums, n)\n\n    # Return the solution\n    return \"Possible\\n\" + str(res)\n\ndef is_valid(nums, n):\n    total = 0\n    for i in nums:\n        total += i\n\n    return total == n\n\ndef find_solution(nums, n):\n    for i in range(1, n + 1):\n        nums.append(i)\n        if is_valid(nums, n):\n            return nums\n\n    return \"No solution found\"", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, T = map(int, input().split())\n\nt = list(map(int, input().split()))\n\nt.sort()\n\n# Calculate the maximum number of bowls that can be eaten\nmax_ Bowls = 0\ncurrent_Position = 0\ncurrent_Time = 0\n\nfor i in range(n):\n    if t[i] - current_Time >= current_Position:\n        max_ Bowls += 1\n        current_Position += 1\n        current_Time = t[i]\n\nprint(max_ Bowls)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\ncrush = list(map(int, input().split()))\n\npossible = False\nt = 1\nwhile not possible:\n    for i in range(n):\n        if crush[i] == i and crush[crush[i]] == i:\n            for j in range(i, n):\n                if crush[j] == i and crush[crush[j]] == j:\n                    t += 1\n                    possible = True\n    if not possible:\n        t = -1\n\nprint(t)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\ns = input()\n\ncnt8 = 0\nfor x in s:\n    if(x == '8'):\n        cnt8 += 1\n\nprint(min(cnt8, n // 11))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import calendar\n\ndef check_days(day1, day2):\n    # Create a dictionary to store the days of the week\n    days_dict = {\"monday\": 1, \"tuesday\": 2, \"wednesday\": 3, \"thursday\": 4, \"friday\": 5, \"saturday\": 6, \"sunday\": 7}\n\n    # Get the number of the first day of the month for the given year\n    month_start = calendar.monthrange(2023, 1)[0]\n\n    # Check if the first day of the month is equal to day1\n    if days_dict[day1] == month_start:\n        # Get the number of the first day of the next month\n        next_month_start = calendar.monthrange(2023, 2)[0]\n\n        # Check if the first day of the next month is equal to day2\n        if days_dict[day2] == next_month_start:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read the input\nday1 = input().lower()\nday2 = input().lower()\n\n# Check if the desired situation is possible\nprint(check_days(day1, day2))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, k = map(int, input().split())\na = input()\nd = a[0:k]\nc = int(d)\nb=d*(n//k)\nprint(n)\nb+=d[0:n%k]\nif(b>=a):\n    print(b)\nelse:\n    c+=1\n    d=str(c)\n    b=d*(n//k)\n    b+=d[0:n%k]\n    print(b)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import numpy as np\n\nn, l, v_1, v_2, k = map(int, input().split())\n\n# Calculate the time taken by each pupil to reach the place of excursion\ntime_taken = l / v_1\n\n# Calculate the time taken to fill the bus\ntime_taken_bus = l / v_2\n\n# Calculate the time taken to get all pupils on the bus\ntime_taken_embarkation = np.ceil(n/k) * time_taken_bus\n\n# Calculate the total time\ntime_taken_total = time_taken_embarkation + time_taken\n\n# Print the time taken\nprint(time_taken_total)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum possible value of the final element\nmax_final_element = max(a)\n\n# Find the number of operations that are performed\noperations = 0\ncurrent_size = len(a)\n\n# Iterate over the operations until the length of the sequence is 1\nwhile current_size > 1:\n    # Choose the element to delete\n    x = a[0] if a[0] == a[len(a) - 1] else a[1]\n\n    # Replace the element with the sum of the two adjacent elements\n    a[0] = a[1] + a[2] if a[0] == a[len(a) - 1] else a[0] = a[2]\n\n    # Delete the element and its two adjacent elements\n    operations += 1\n    current_size -= 2\n\n# Print the maximum possible value of the final element\nprint(max_final_element)\n\n# Print the number of operations that are performed\nprint(operations)\n\n# Print the elements that are deleted in each operation\nfor i in range(operations):\n    print(a[i])", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "I=lambda:list(map(int,input().split()))\nR=list(range(999))\nq,w,e=I()\nr,t,y=I()\na,b,c=I()\nprint(min(i*b+j*c+max(0,(r//(w+i-y)+bool(r%(w+i-y)))*(t-e-j)-q+1)*a for i in R for j in R if w+i>y))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the multiples of each gem.\nmultiples = {}\nfor i in range(1, n + 1):\n    for multiple in range(i, n + 1, i):\n        if multiple not in multiples:\n            multiples[multiple] = 0\n        multiples[multiple] += 1\n\n# Calculate the total yen earned.\ntotal_yen = 0\nfor i in range(1, n + 1):\n    if multiples[i] == 0:\n        total_yen += a[i - 1]\n\n# Print the maximum amount of money that can be earned.\nprint(total_yen)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "__author__ = 'Alexander'\nimport sys\nformat = int(sys.stdin.readline().strip())\ntimeH, timeM = list(map(int,sys.stdin.readline().split(':')))\n# print(format)\n# print(timeH)\n# print(timeM)\nif format == 12:\n    if timeH > 12 or timeH == 0:\n        if timeH == 0: timeH = 1\n        elif timeH%10 == 0: timeH = 10\n        else: timeH %= 10\n    if timeM > 59:\n        timeM %= 10\nelse:\n    if timeH > 23:\n        timeH %= 10\n    if timeM > 59:\n        timeM %= 10\nsys.stdout.write(\"%02d:%02d\" % (timeH, timeM))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\ns = input().split()\ns = [int(x) for x in s]\n\n# Check if there is at least one phone number that can be made\nif any(len(str(x)) == 11 and str(x).startswith('8') for x in s):\n    # Calculate the maximum number of phone numbers that can be made\n    max_phone_numbers = sum(1 for x in s if len(str(x)) == 11 and str(x).startswith('8'))\n    print(max_phone_numbers)\nelse:\n    print(0)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\ng = [list(map(int, input().split())) for _ in range(m)]\n\n# Create a dictionary to store the graph\ngraph = {i: set() for i in range(n)}\nfor u, v in g:\n    graph[u].add(v)\n\n# Check if the graph can be created from a string\ns = ''.join(['a' if v == 1 else 'b' if v == 2 else 'c' for v in graph])\nif s and graph[i] == set(graph[i] for i in s):\n    print('Yes')\n    print(s)\nelse:\n    print('No')", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "q = int(input())\n\nfor _ in range(q):\n    n, k = map(int, input().split())\n    f = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\n    s = f + f\" \" * n\n    print(s[k-1])", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "#!/usr/bin/env python3\n\ndef main():\n    from collections import Counter\n\n    try:\n        while True:\n            c = Counter(input())\n            print(min(c['B'], c['u'] >> 1, c['l'], c['b'], c['a'] >> 1, c['s'], c['r']))\n\n    except EOFError:\n        pass\n\nmain()\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "3\nn = int(input())\na = list(map(float, input().split()))\na_s = sum(a)\na_r = []\nfor i in range(n):\n    i_max = int(a[i])\n    i_min = int(a[i]) - 1\n    a_r.append(abs((a[i] - i_max) - (a[i] - i_min)))\nprint(min(a_r))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\n\nroman_dict = {1: 1, 5: 5, 10: 10, 50: 50}\n\ndef count_roman_numeral(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        num_digits = len(str(i))\n        if num_digits == 1:\n            count += roman_dict[i]\n        elif num_digits == 2:\n            count += roman_dict[i] * 2\n    return count\n\nprint(count_roman_numeral(n))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\nm = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif sum(a) <= m and sum(b) <= m:\n    f = (m - sum(a)) // sum(b)\n    print(f)\nelse:\n    print(-1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "from sys import stdin\ninput=stdin.readline\nn,I=map(int,input().split())\na=sorted(list(map(int,input().split())))\nkey=[]\nk=min(I*8//n,20)\nK=min(2**k,n)\nlast=-1\nfor i in range(n):\n    if a[i]==last:\n        key[-1]+=1\n    else:\n        key.append(1)\n        last=a[i]\nnow=0\nbest=0\nfor i in range(len(key)):\n    if i<K:\n        now+=key[i]\n    else:\n        now+=key[i]\n        now-=key[i-K]\n    best=max(now,best)\nprint(n-best)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\ng = input().split()\n\n# Create a map to store the positions of packmen and asterisks\npos = {}\nasterisks = {}\nfor i in range(n):\n    if g[i] == 'P':\n        pos[i] = 'P'\n    elif g[i] == '*':\n        asterisks[i] = True\n\n# Calculate the minimum time to eat all asterisks\ntime = 0\nfor i in pos:\n    # Calculate the distance to the nearest asterisk\n    distance = min(abs(i - x) for x in asterisks)\n    # Update the minimum time if necessary\n    time = max(time, distance)\n\n# Print the minimum time\nprint(time)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "from math import factorial\nMOD = 10**9+7\n\nk = int(input())\nbink = list(map(int, bin(k)[2:]))\nN = len(bink)\n\n# dp[i][j][k] = first i bits, j bases,\n#   k = 1 if maxor matches k, 0 else\ndp = [[[0,0] for j in range(i+2)] for i in range(N+1)]\ndp[0][0][1] = 1\nfor i in range(1, N+1):\n    for j in range(i+1):\n        # k = 0 -> 0\n        dp[i][j][0]+= 2**j * dp[i-1][j][0] # distribute\n        if j: dp[i][j][0]+= dp[i-1][j-1][0] # new base\n        # k = 1 -> 0\n        odd = 2**(j-1) if j else 0\n        even = 2**j - odd\n        if bink[i-1] == 1:\n            dp[i][j][0]+= even * dp[i-1][j][1] # distribute even\n        # k = 1 -> 1\n        if bink[i-1] == 0:\n            dp[i][j][1]+= even * dp[i-1][j][1] # distribute even\n        else:\n            dp[i][j][1]+= odd * dp[i-1][j][1] # distribute odd\n            if j: dp[i][j][1]+= dp[i-1][j-1][1] # new base\nans = sum(map(sum, dp[-1]))\nprint(ans % MOD)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import sys\ndef factorial():\n    nonlocal mod\n    fac = [1] * int(3e5 + 1)\n    for i in range(1, int(3e5)):\n        fac[i] = i*fac[i-1] % mod\n    return fac\ndef inverse(x):\n    nonlocal mod\n    return pow(x, mod-2, mod)\ndef C(n, r):\n    nonlocal fac\n    if n < 0 or n < r:\n        return 0\n    return fac[n]*inverse(fac[r])*inverse(fac[n-r]) % mod\ndef calc(f, w, h):\n    nonlocal mod\n    if w == 0:\n        return 1\n    ans = 0\n    for k in range(1, min(w//(h+1),f+1)+1):\n        ans += C(f+1, k) * C(w-k*h-1, k-1) % mod\n        ans %= mod\n    return ans\nf, w, h = list(map(int,sys.stdin.readline().split(' ')))\nmod = int(1e9 + 7)\nfac = factorial()\ncnt = calc(f, w, h)\nsys.stdout.write(str(cnt*inverse(C(f+w, w)) % mod))\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n,m=sorted(map(int,input().split()))\nprint(~1&n*m-{1:2*(1<m%6<5),2:{2:4,3:2,7:2}.get(m,0)}.get(n,0))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\nd = [[10 ** 6] * 3 for i in range(n)]\nd[0][0] = 1\nif a[0] & 1:\n    d[0][1] = 0\nif a[0] & 2:\n    d[0][2] = 0\n\nfor i in range(1, n):\n    d[i][0] = min(d[i - 1]) + 1\n    if a[i] & 1:\n        d[i][1] = min(d[i - 1][0], d[i - 1][2])\n    if a[i] & 2:\n        d[i][2] = min(d[i - 1][0], d[i - 1][1])\n\nprint(min(d[-1]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import sys\ninput = sys.stdin.readline\nN = int(input())\nA = list(map(int,input().split()))\nB = [int(input()) for i in range(N-1)]\n\ndef mex(x,y):\n    if x+y==1: return 2\n    if x==0 or y==0: return 1\n    return 0\n\nn = min(4,N)\narr = [[-1]*n for _ in range(n)]\nfor i,a in enumerate(A):\n    if i>=4: break\n    arr[0][i] = a\nfor i,b in enumerate(B):\n    if i+1>=4: break\n    arr[i+1][0] = b\nfor i in range(1,n):\n    for j in range(1,n):\n        arr[i][j] = mex(arr[i-1][j], arr[i][j-1])\n\nfrom collections import Counter\nctr = Counter()\nfor i in range(n):\n    for j in range(n):\n        ctr[arr[i][j]] += 1\nif N <= 4:\n    print(ctr[0], ctr[1], ctr[2])\n    return\n\narrtop = [[-1]*(N-3) for _ in range(4)]\nfor i in range(4):\n    arrtop[i][0] = arr[i][-1]\nfor j in range(4,N):\n    arrtop[0][j-3] = A[j]\nfor i in range(1,4):\n    for j in range(1,N-3):\n        arrtop[i][j] = mex(arrtop[i-1][j], arrtop[i][j-1])\nfor i in range(4):\n    for j in range(1,N-3):\n        ctr[arrtop[i][j]] += (1 if i<3 else N-3-j)\n\narrleft = [[-1]*4 for _ in range(N-3)]\nfor j in range(4):\n    arrleft[0][j] = arr[-1][j]\nfor i in range(4,N):\n    arrleft[i-3][0] = B[i-1]\nfor i in range(1,N-3):\n    for j in range(1,4):\n        arrleft[i][j] = mex(arrleft[i-1][j], arrleft[i][j-1])\nfor i in range(1,N-3):\n    for j in range(4):\n        ctr[arrleft[i][j]] += (1 if j<3 else N-3-i)\n\nctr[arr[-1][-1]] += N-4\nprint(ctr[0], ctr[1], ctr[2])", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, p = map(int, input().split())\nt = [ord(c) - 97 for c in input()] + [27, 27]\nfor k in range(n - 1, -1, -1):\n    for i in range(t[k] + 1, p):\n        if i - t[k - 1] and i - t[k - 2]:\n            a, b = min(t[k - 1], 2), min(i, 2)\n            if a == b: a = 1\n            t = t[: k] + [i] + [3 - a - b, a, b] * (n // 3 + 1)\n            print(''.join(chr(i + 97) for i in t)[: n])\n            return\nprint('NO')", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import math\nmod = 998244353\nn = int(input())\np = [list(map(int, input().split())) for i in range(n)]\npow2 = [1]\nfor i in range(n):\n    pow2.append(pow2[-1] * 2 % mod)\nused = [[False] * n for i in range(n)]\nret = (pow2[n] - 1 - n - n * (n - 1) / 2) % mod\nfor i in range(n):\n    for j in range(i):\n        if used[i][j]:\n            continue\n        inline = [i, j]\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            if (p[i][1] - p[k][1]) * (p[j][0] - p[k][0]) == (p[j][1] - p[k][1]) * (p[i][0] - p[k][0]):\n                inline.append(k)\n        for k in range(len(inline)):\n            for l in range(len(inline)):\n                used[inline[k]][inline[l]] = True\n        v = len(inline)\n        ret = (ret + mod - pow2[v] + 1 + v + v * (v - 1) // 2) % mod\nprint((int(ret)))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n, k = map(int, input().split())\ns = input().strip()\n\n# Calculate the total number of moves\nmoves = 0\nfor i in range(n-k+1):\n    if s[i] != s[i+k]:\n        moves += 1\n\n# Check if the total number of moves exceeds 10^9\nif moves > 1e9:\n    print(\"once again\")\nelse:\n    # Check if Tokitsukaze will win\n    if s.startswith(s[0] * k) or s.endswith(s[n-1] * k):\n        print(\"tokitsukaze\")\n    # Otherwise, Quailty will win\n    else:\n        print(\"quailty\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\nseq = list(map(int, input().split(\" \")))\n\nif sum(seq) < 3 or sum(seq) == 5:\n\tprint(-1)\n\nelse:\n\tarr = [0,0,0,0,0]\n\tfor s in seq:\n\t\tarr[s] += 1\n\t#print(arr)\n\t\n\tans = 0\n\tif arr[2] >= arr[1]:\n\t\tans += arr[1]\n\t\tarr[2] -= arr[1]\n\t\tarr[3] += arr[1]\n\t\tarr[1] = 0\n\telse:\n\t\tans += arr[2]\n\t\tarr[1] -= arr[2]\n\t\tarr[3] += arr[2]\n\t\tarr[2] = 0\n\t#print(arr, ans)\n\t\n\n\tans += 2*(arr[1]//3)\n\tarr[3] += arr[1]//3\n\tarr[1] %= 3\n\t#print(arr, ans)\n\t\n\tif (arr[3] >= arr[1]):\n\t\tans += arr[1]\n\t\tarr[4] += arr[1]\n\t\tarr[3] -= arr[1]\n\t\tarr[1] = 0\n\telse:\n\t\tif arr[1] < 2:\n\t\t\tans += arr[3]\n\t\t\tarr[4] += arr[3]\n\t\t\tarr[1] -= arr[3]\n\t\t\tarr[3] = 0\n\t#print(arr, ans)\n\t\n\tif arr[1] > 0:\n\t\tif arr[1] == 2:\n\t\t\tans += arr[1]\n\t\t\tarr[4] -= 1\n\t\t\tarr[3] += 2\n\t\t\tarr[1] = 0\n\t\telse:\n\t\t\tans += 2\n\t\t\tarr[4] -= 2\n\t\t\tarr[3] += 2\n\t\t\tarr[1] = 0\n\t\n\tans += 2*(arr[2]//3)\n\tarr[3] += 2*(arr[2]//3)\n\tarr[2] %= 3\n\t#print(arr, ans)\n\t\n\tif arr[2] > 0:\n\t\tif (arr[4] >= arr[2]):\n\t\t\tans += arr[2]\n\t\t\tarr[4] -= arr[2]\n\t\t\tarr[3] += 2*arr[2]\n\t\t\tarr[2] = 0\n\t\t\t#print(arr, ans)\n\t\t\t\n\t\t\tans += 2*(arr[2])\n\t\t\tarr[4] += 2*arr[2]\n\t\t\tarr[3] -= arr[2]\n\t\t\tarr[2] = 0\n\t\t\t#print(arr, ans)\n\t\telse:\n\t\t\tif (arr[4] > 0):\n\t\t\t\tans += arr[2]\n\t\t\t\tarr[4] -= arr[2]\n\t\t\t\tarr[3] += 2*arr[2]\n\t\t\t\tarr[2] = 0\n\t\t\t\t#print(arr, ans)\n\t\t\telse:\n\t\t\t\tif arr[2] == 1:\n\t\t\t\t\tans += 2*arr[2]\n\t\t\t\t\tarr[3] += 2\n\t\t\t\t\tarr[2] = 0\n\t\t\t\telse:\n\t\t\t\t\tans += arr[2]\n\t\t\t\t\tarr[4] += 1\n\t\t\t\t\tarr[2] = 0\n\t\n\tprint(ans)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\nt = list(map(int, input().split()))\n\nt.sort()\n\nif len(set(t)) == 3 and t[1] - t[0] <= 2 and t[2] - t[1] <= 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\nm = min(a)\nM = max(a)\ncount = 0\nfor el in a:\n    if el != m and el != M:\n        count += 1\nprint(count)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\gemma-7b-it-apps_competition_207.jsonl"}
{"code": "import math\n\ndef min_time(n, p, q, a, b):\n    dp = [[math.inf] * (p + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(p + 1):\n            for k in range(min(j // a[i - 1], q // b[i - 1]) + 1):\n                dp[i][j] = min(dp[i][j], dp[i - 1][max(0, j - a[i - 1] * k)] + k)\n    return dp[n][p] / q\n\nn, p, q = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(min_time(n, p, q, a, b))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import collections\n\ndef dfs(i, j, grid, visited, val):\n    if i < 0 or i >= n or j < 0 or j >= m or visited[i][j] or grid[i][j] != val:\n        return\n    visited[i][j] = True\n    dfs(i+1, j, grid, visited, val)\n    dfs(i-1, j, grid, visited, val)\n    dfs(i, j+1, grid, visited, val)\n    dfs(i, j-1, grid, visited, val)\n\nn, m, k = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# find connected components\nvisited = [[False]*m for _ in range(n)]\ncomponents = []\nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j]:\n            component = []\n            dfs(i, j, grid, visited, grid[i][j])\n            component.append((i, j))\n            for x, y in component:\n                visited[x][y] = len(components) + 1\n            components.append(component)\n\n# check if it is possible to make all connected components of the same values form rectangles\nfor i in range(len(components)):\n    for j in range(i+1, len(components)):\n        if grid[components[i][0][0]][components[i][0][1]] == grid[components[j][0][0]][components[j][0][1]]:", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input())\nxi = list(map(int, input().split()))\n\n# Initialize the number of piles to 0\npiles = 0\n\n# Iterate over the boxes from right to left\nfor i in range(n - 1, -1, -1):\n    # If the current box can't support any more boxes, we need to start a new pile\n    if xi[i] == 0:\n        piles += 1\n    # Otherwise, we can add the current box to the top of the previous pile\n    # We just need to make sure that the previous pile has enough capacity\n    # To do this, we update the capacity of the previous pile to be the minimum of its current capacity and the strength of the current box\n    else:\n        xi[i - 1] = min(xi[i - 1], xi[i])\n\nprint(piles)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import math\n\ndef min\\_fuel():\n    n = int(input().strip())\n    m = float(input().strip())\n    a = list(map(int, input().strip().split()))\n    b = list(map(int, input().strip().split()))\n\n    takeoff = [m / i for i in a]\n    landing = [m / j for j in b]\n\n    min\\_fuel\\_needed = math.inf\n\n    for i in range(n):\n        takeoff\\_fuel = takeoff[i]\n        landing\\_fuel = landing[(i + 1) % n]\n\n        if takeoff\\_fuel < landing\\_fuel:\n            fuel\\_needed = takeoff\\_fuel\n        else:\n            fuel\\_needed = landing\\_fuel\n\n        min\\_fuel\\_needed = min(min\\_fuel\\_needed, fuel\\_needed)\n\n        m -= fuel\\_needed\n\n    if m > 0:\n        min\\_fuel\\_needed = -1\n\n    print(\"{:.12f}\".format(min\\_fuel\\_needed))\n\nmin\\_fuel()", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input().strip())\nsizes = []\nfor _ in range(n):\n    k, a = map(int, input().strip().split())\n    sizes.append((k, a))\n\nsizes.sort(key=lambda x: x[0])\n\ncurr\\_size = 0\nfor k, a in sizes:\n    if 2**k <= curr\\_size:\n        continue\n    else:\n        curr\\_size = 2**(k+1) - 1\n\nprint(sizes[-1][0] + 1)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = input()\nn = int(n)\narr = [0] * n\nfact = [0] * 51\na = input().split()\np = input()\np = int(p)\n\nfor i in range(n):\n\tarr[i] = int(a[i])\n\nif n == 1:\n\tif arr[0] <= p:\n\t\tprint(1)\n\telse:\n\t\tprint(0)\n\treturn\n\ndef pre():\n\tfact[0] = 1\n\tfor i in range(1, 51):\n\t\tfact[i] = fact[i - 1] * i\n\ndef get(arr, min_sum, max_sum):\n\tways = [[0 for i in range(max_sum + 1)] for i in range(len(arr) + 1)]\n\tways[0][0] = 1\n\tfor i in range(len(arr)):\n\t\tfor j in range(i, -1, -1):\n\t\t\tfor k in range(max_sum, -1, -1):\n\t\t\t\tif k + arr[i] <= max_sum:\n\t\t\t\t\tways[j + 1][k + arr[i]] += ways[j][k]\n\n\tans = 0\n\tcounted = 0\n\tfor i in range(0, len(arr) + 1):\n\t\tfor j in range(min_sum, max_sum + 1):\n\t\t\tans += fact[i] * fact[n - i - 1] * ways[i][j] * i\n\t\t\tcounted += fact[i] * fact[n - i - 1] * ways[i][j]\n\n\treturn ans, counted\n\npre()\ntot = 0\ncount = 0\nsm = 0\nfor i in range(n):\n\tsm += arr[i]\n\tarr1 = [0] * (n - 1)\n\tgot = 0\n\tfor j in range(n):\n\t\tif j == i:\n\t\t\tcontinue\n\t\tarr1[got] = arr[j]\n\t\tgot += 1\n\thow_many = get(arr1, max(0, p - arr[i] + 1), p)\n\ttot += how_many[0]\n\tcount += how_many[1]\n\ndef get_div(a, b):\t#a / b\n\tres = a // b\n\ta %= b\n\tfor i in range(1, 10):\n\t\ta = int(a)\n\t\ta *= 10\n\t\tx = a // b\n\t\tx1 = x\n\t\tres += pow(10, -i) * x1\n\t\ta -= x * b\n\treturn res\n\nif sm <= p:\n\tprint(n)\nelse:\n\tprint(get_div(tot, fact[n]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def hanoi\\_min\\_cost(t, n):\ncosts = [[0 for _ in range(3)] for _ in range(n)]\ncosts[0] = [t[0][1], t[0][2], 0]\n\nfor i in range(1, n):\nfor j in range(3):\ncosts[i][j] = min(costs[i-1][k] + t[k][j] for k in range(3) if k != j)\n\nreturn costs[n-1][2]\n\nif **name** == '**main**':\nt = [[0, 1, 1], [1, 0, 1], [1, 1, 0]]\nn = 3\nprint(hanoi\\_min\\_cost(t, n))\n\nt = [[0, 2, 2], [1, 0, 100], [1, 2, 0]]\nn = 3\nprint(hanoi\\_min\\_cost(t, n))\n\nt = [[0, 2, 1], [1, 0, 100], [1, 2, 0]]\nn = 5\nprint(hanoi\\_min\\_cost(t, n))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "# https://codeforces.com/contest/883/problem/K\n# WA\nimport heapq\nfrom heapq import heappush as push_\nfrom heapq import heappop  as pop_\n\nn  =  int(input())\np  =  [list(map(int, input().split())) for _ in range(n)] \nQ  =  []\nd  =  [s+g for s, g in p]\n\nfor i, [s, g] in enumerate(p):\n    push_(Q, (s+g, i))\n    \nflg = True\nwhile len(Q) > 0:\n    S, ind = pop_(Q)\n    \n    if S > d[ind]:\n        continue\n    \n    if ind > 0 and d[ind-1] > S+1:\n        if S+1 < p[ind-1][0]:\n            flg=False\n            break\n            \n        d[ind-1]  = S+1\n        push_(Q, (d[ind-1], ind-1))\n        \n    if ind < n-1 and d[ind+1] > S+1:\n        if S+1 < p[ind+1][0]:\n            flg=False\n            break\n            \n        d[ind+1]  = S+1\n        push_(Q, (d[ind+1], ind+1))    \n    \nif flg==False:\n    print(-1)\nelse:\n    print(sum([d[i]-p[i][0] for i in range(n)]))\n    print(' '.join([str(x) for x in d]))\n    \n#3\n#4 5\n#4 5\n#4 10       \n\n#4\n#1 100\n#100 1\n#1 100\n#100 1\n\n#3\n#1 1\n#100 100\n#1 1\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "mod = int(1e9 + 7)\nn, m = map(int, input().split())\nf = [ [0 for i in range(60)] for j in range(60) ]\ng = [ [0 for i in range(60)] for j in range(60) ]\ns = [ [0 for i in range(60)] for j in range(60) ]\ninv = [ 1 ]\nf[0][0] = s[0][0] = 1\n\ndef pow(x, exp) :\n    res = 1\n    for i in range(0, 31) :\n        if exp & 1 : res = res * x % mod\n        exp >>= 1\n        if exp == 0 : break\n        x = x * x % mod\n    return res\n\nfor i in range(1, n + 1) :\n    inv.append( pow(i, mod - 2) )\n\nfor node in range(1, n + 1) :\n    for cut in range(1, n + 1) :\n        tmp = 0\n        for ln in range(node) :\n            for lc in range(cut - 1, n + 1) :\n                if f[ln][lc] == 0 : continue\n                if lc == cut - 1 :\n                    tmp = ( tmp + f[ln][lc] * s[node - ln - 1][cut - 1] ) % mod\n                else :\n                    tmp = ( tmp + f[ln][lc] * f[node - ln - 1][cut - 1] ) % mod\n        cnt = 1\n        if tmp != 0 :\n            cn, cc = 0, 0\n            for i in range(1, n + 1) :\n                cn += node\n                cc += cut\n                cnt = cnt * (tmp + i - 1) % mod * inv[i] % mod\n                if cn > n or cc > n : break\n                for j in range(n - cn, -1, -1) :\n                    for k in range(n - cc, -1, -1) :\n                        if f[j][k] == 0 : continue\n                        g[j + cn][k + cc] += f[j][k] * cnt\n                        g[j + cn][k + cc] %= mod\n            for i in range(n + 1) :\n                for j in range(n + 1) :\n                    f[i][j] = (f[i][j] + g[i][j]) % mod\n                    g[i][j] = 0\n            \n    for cut in range(n, -1, -1) :\n        s[node][cut] = ( s[node][cut + 1] + f[node][cut] ) % mod\nprint(f[n][m - 1])", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "s = input().rstrip()\ns += \"T\"\nx, y = list(map(int, input().split()))\ncnt = 0\ndir = 0\nP = [{0},{0}]\nfirst = True\nfor i in range(len(s)):\n    if s[i]==\"F\":\n        cnt+=1\n    else:\n        tmp = set()\n        if first:\n            for p in P[dir%2]:\n                tmp |= {p+cnt}\n            first=False\n        else:\n            for p in P[dir%2]:\n                tmp |= {p+cnt, p-cnt}\n        P[dir%2] =tmp\n        dir += 1\n        cnt = 0\nif x in P[0] and y in P[1]:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "from collections import deque\n\nn, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nc50 = sum([1 for i in a if i == 50])\nc100 = sum([1 for i in a if i == 100])\nc = [[0] * 51 for i in range(51)]\nc[0][0] = 1\nc[1][0] = 1\nc[1][1] = 1\nfor x in range(2, 51):\n    for y in range(x + 1):\n        c[x][y] = c[x - 1][y - 1] + c[x - 1][y]\nd = [[[[0, float('inf')] for l in range(2)] for i in range(c100 + 1)] for j in range(c50 + 1)]\n# d[i][j][c] \u043e\u0442\u0432\u0435\u0442, \u043a\u043e\u0433\u0434\u0430 \u043c\u044b \u043f\u0435\u0440\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u0438 i \u043f\u043e 50 \u043a\u0433 \u0438 j \u043f\u043e 100 \u043a\u0433 \u0438 \u043b\u043e\u0434\u043a\u0430 \u043d\u0430 \u0431\u0435\u0440\u0435\u0433\u0443 c\nd[0][0][0][0] = 1\nd[0][0][0][1] = 0\nq = deque()\nq.append([0, 0, 0])\nwhile len(q) > 0:\n    i, j, shore = q.popleft()\n    for fifty in range(c50 - i + 1 if shore == 0 else i + 1):\n        for hundreds in range(c100 - j + 1 if shore == 0 else j + 1):\n            if fifty * 50 + hundreds * 100 > k or fifty + hundreds == 0:\n                continue\n            i1 = i + fifty if shore == 0 else i - fifty\n            j1 = j + hundreds if shore == 0 else j - hundreds\n            if d[i1][j1][1 ^ shore][1] > d[i][j][shore][1] + 1:\n                d[i1][j1][1 ^ shore][1] = d[i][j][shore][1] + 1\n                d[i1][j1][1 ^ shore][0] = 0\n                q.append((i1, j1, 1 ^ shore))\n            if d[i1][j1][1 ^ shore][1] < d[i][j][shore][1] + 1:\n                continue\n            koeff = (c[c50 - i][fifty] if shore == 0 else c[i][fifty]) * (\n                c[c100 - j][hundreds] if shore == 0 else c[j][hundreds])\n            d[i1][j1][1 ^ shore][0] += d[i][j][shore][0] * koeff\n            d[i1][j1][1 ^ shore][0] %= 10 ** 9 + 7\nif d[c50][c100][1][1] == float('inf'):\n    print(-1)\n    print(0)\nelse:\n    print(d[c50][c100][1][1])\n    print(d[c50][c100][1][0])\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n,l,v1,v2,k=list(map(int,input().split()))\n\nn=(n+k-1)//k\n\na=(v2-v1)/(v1+v2)\n\nt=l/v2/(n-(n-1)*a)\n\nprint(n*t+(n-1)*a*t)\n\n\n\n# Made By Mostafa_Khaled\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\ns = input()\nt = input()\n\ni, j = 0, 0\nwhile i < n and j < m:\n    if s[i] == '*':\n        i += 1\n        continue\n    if s[i] != t[j]:\n        break\n    i += 1\n    j += 1\n\nif i < n:\n    print(\"NO\")\nelse:\n    print(\"YES\")", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "#\t!/bin/env python3\n#\tcoding: UTF-8\n\n\n#\t\u272a H4WK3yE\u4e61\n#\tMohd. Farhan Tahir\n#\tIndian Institute Of Information Technology and Management,Gwalior\n\n#\tQuestion Link\n#\thttps://codeforces.com/problemset/problem/392/B\n#\n\n# ///==========Libraries, Constants and Functions=============///\n\n\nimport sys\n\ninf = float(\"inf\")\nmod = 1000000007\n\n\ndef get_array(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef get_ints(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef input(): return sys.stdin.readline()\n\n# ///==========MAIN=============///\n\n\ndef main():\n    dp = [[[0 for _ in range(3)] for _ in range(3)] for _ in range(43)]\n    matrix = [[0 for _ in range(3)] for _ in range(3)]\n    for i in range(3):\n        matrix[i] = get_array()\n    n = int(input())\n    for i in range(1, n+1):\n        for frm in range(3):\n            for to in range(3):\n                other = 3-frm-to\n                if frm == to:\n                    continue\n                dp[i][frm][to] = dp[i-1][frm][other]+matrix[frm][to]+dp[i-1][other][to]\n                c = dp[i-1][frm][to]+matrix[frm][other] + \\\n                    dp[i-1][to][frm]+matrix[other][to]+dp[i-1][frm][to]\n                dp[i][frm][to] = min(c, dp[i][frm][to])\n    print(dp[n][0][2])\n\n\ndef __starting_point():\n    main()\n\n__starting_point()", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "a,b=map(int,input().split())\nans=1;mod=1000000009;gh=pow(2,b,mod)\nfor i in range(1,1+a):ans=(ans*(gh-i))%mod\nprint(ans)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def min\\_decks(b, g, n):\nif b+g < n or n > b or n > g:\nreturn -1\n\ndecks = 0\nwhile b <= n and g <= n:\nb -= min(n, b)\ng -= min(n, g)\ndecks += 1\nn -= 1\n\nreturn decks\n\nb = int(input())\ng = int(input())\nn = int(input())\n\nresult = min\\_decks(b, g, n)\n\nif result == -1:\nprint(\"No solution\")\nelse:\nprint(result)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "#!/usr/bin/env python3\n\ndef main():\n    from collections import Counter\n\n    try:\n        while True:\n            c = Counter(input())\n            print(min(c['B'], c['u'] >> 1, c['l'], c['b'], c['a'] >> 1, c['s'], c['r']))\n\n    except EOFError:\n        pass\n\nmain()\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def find\\_common\\_number(n, pairs1, m, pairs2):\npossible\\_pairs = set()\nfor a, b in pairs1:\nfor c, d in pairs2:\nif a == c or a == d or b == c or b == d:\npossible\\_pairs.add((a, b))\npossible\\_pairs.add((c, d))\n\nif len(possible\\_pairs) == 1:\nreturn list(possible\\_pairs.pop())[0]\n\nfor a, b in pairs1:\nif possible\\_pairs.intersection({(a, i) for i in range(1, 10)})\\\n& possible\\_pairs.intersection({(j, b) for j in range(1, 10)}):\nreturn 0\n\nreturn -1\n\n# Test cases\nprint(find\\_common\\_number(2, [(1, 2), (3, 4)], 2, [(1, 5), (3, 4)])) # 1\nprint(find\\_common\\_number(2, [(1, 2), (3, 4)], 2, [(1, 5), (6, 4)])) # 0\nprint(find\\_common\\_number(2, [(1, 2), (4, 5)], 3, [(1, 2), (1, 3), (2, 3)])) # -1", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\n\ndef duel(n, k, s):\n    if (n - 1) % (k - 1) != 0:\n        return \"tokitsukaze\" if k % 2 == 1 else \"quailty\"\n    if \"1\" not in s and \"0\" not in s:\n        return \"once again\"\n    if k == 1:\n        return \"quailty\" if \"1\" in s else \"tokitsukaze\"\n    if k == n:\n        return \"tokitsukaze\" if s[0] == s[-1] else \"quailty\"\n    if s[0] != s[-1]:\n        return \"once again\"\n    for i in range(1, n - k + 1):\n        if s[i:i + k] != s[i - 1] * k:\n            return \"once again\"\n    return \"tokitsukaze\" if s[0] == \"1\" else \"quailty\"\n\nif __name__ == '__main__':\n    lines = sys.stdin.readlines()\n    n, k = map(int, lines[0].split())\n    s = lines[1].strip()\n    print(duel(n, k, s))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def rp():\n    cs = list(map(int, input().split(' ')))\n    cs = list(zip(cs[0::2], cs[1::2]))\n    return cs\n\ndef dist(p1, p2):\n    return len(set(p1).union(set(p2))) - 2\n\ninput()\n\nps = [rp(), rp()]\n\ntheyCan = True\nmyPos = set()\n\nfor ps1, ps2 in [ps, ps[::-1]]:\n    for p1 in ps1:\n        pos = set()\n\n        for p2 in ps2:\n            if dist(p1, p2) == 1:\n                pos = pos.union( set(p1).intersection(set(p2)) )\n        \n        if len(pos) >= 2:\n            theyCan = False\n        myPos = myPos.union(pos)\n\nprint(next(iter(myPos)) if len(myPos)==1 else 0 if theyCan else -1)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n, c = 0, 0\ndef dfs(now, m, t):\n\tnonlocal n, c\n\tif now == 0:\n\t\tif m > n:\n\t\t\tn, c = m, t\n\t\treturn\n\ti = 1\n\twhile i**3 <= now:\n\t\ti += 1\n\ti -= 1\n\tdfs(now-i**3, m+1, t+i**3)\n\tdfs(i**3-1-(i-1)**3, m+1, t+(i-1)**3)\nm = int(input())\ndfs(m, 0, 0)\nprint(n, c) ", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "R = lambda: map(int, input().split())\nmod = 10 ** 9 + 7\nmaxn = 1001\nc = [[0 for j in range(maxn)] for i in range(maxn)]\nfor i in range(maxn):\n    c[i][0] = 1\nfor i in range(1, maxn):\n    for j in range(i + 1):\n        c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod\narr = list(map(int, input()))\nk = int(input())\nif k == 0:\n    print(1 if arr.count(1) else 0)\n    return\nops = [0] * (maxn + 1)\nans = 0\nfor i in range(2, maxn):\n    cnt = bin(i).count('1')\n    ops[i] = ops[cnt] + 1\nfor i in range(1, maxn):\n    if ops[i] == k - 1:\n        oc = i\n        for j, x in enumerate(arr):\n            if x and oc >= 0:\n                ans = (ans + c[len(arr) - j - 1][oc]) % mod\n                oc -= 1\n        ans = (ans + 1) % mod if arr.count(1) == i else ans\nif k == 1:\n    ans = (ans + mod - 1) % mod\nprint(ans)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\nfrom collections import defaultdict\n\ndef cross_product(p1, p2, p0):\n    return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p1[1] - p0[1]) * (p2[0] - p0[0])\n\ndef leftmost_point(points):\n    return min(points, key=lambda p: p[0])\n\ndef sharestaff(points):\n    n = len(points)\n    if n <= 3:\n        return points\n\n    # Find the leftmost point\n    p0 = leftmost_point(points)\n    points = sorted(points, key=lambda p: cross_product(p0, p, (0, 0)))\n\n    # Initialize the convex hull\n    hull = [p0]\n    for p in points:\n        while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0:\n            hull.pop()\n        hull.append(p)\n\n    # Find the points inside the convex hull\n    inside = set()\n    for p in points:\n        if p not in hull:\n            flag = True\n            for q in hull:\n                if cross_product(p, q, (0, 0)) > 0:\n                    flag = False\n                    break\n            if flag:\n                inside.add(p)\n\n    # Compute the score of each subset of the convex hull\n    mod = 998244353\n    dp = defaultdict(int)\n    dp[frozenset()] = 1\n    for p in hull:\n        new_dp = defaultdict(int)\n        for s, count in dp.items():\n            new_", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "readInts=lambda: list(map(int, input().split()))\nn=int(input())\na=readInts()\np=[0]*n\nfor i in range(n):\n    p[a[i]-1]=i\ninc=1;ret=n-1\n#print(p)\nfor i in range(1,n):\n    if p[i]>p[i-1]:\n        inc+=1\n    else:\n        inc=1\n    ret=min(ret,n-inc)\nprint(ret)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def power(x, y, mod):\n    res = 1\n    x = x % mod\n    while (y > 0):\n        if (y & 1):\n            res = (res * x) % mod\n            y -= 1\n        x = (x * x) % mod\n        y = y >> 1\n    return res\n\ndef solve(n, t):\n    if (t == 1):\n        return n\n    else:\n        ans = power(2, n - 2, mod=1000000007)\n        if (t > n and t <= 2 * n + 1):\n            ans = (ans + (t - n - 1)) % 1000000007\n        return ans\n\nmod = 1000000007\nn, t = map(int, input().split())\nprint(solve(n, t))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def solve\\_rebus(rebus):\nn = int(rebus.split(\"=\")[1])\nops = rebus.split(\"=\")[0].split(\"+\") + rebus.split(\"=\")[0].split(\"-\")\nvalues = set(range(1, n+1))\n\nfor value in values:\nvalues -= set([value])\nif not consistent\\_subset(ops, values, n - value):\nreturn \"Impossible\"\nreturn \"Possible\\n\" + \" + \".join(str(x) for x in ([n] + list(values))) + \" = \" + str(n)\n\ndef consistent\\_subset(ops, values, target):\nif not ops:\nreturn target == 0\nif len(ops) == 1:\nop = ops[0]\nif op == \"+\":\nreturn target in values\nif op == \"-\":\nreturn target == values.pop()\nleft\\_ops, right\\_ops = split\\_ops(ops)\nleft\\_values = values.copy()\nif not consistent\\_subset(left\\_ops, left\\_values, target):\nreturn False\nreturn consistent\\_subset(right\\_ops, values, target - sum(left\\_values))\n\ndef split\\_ops(ops):\nfor i in range(1, len(ops)):\nif ops[i] in {\"+\", \"-\"}:\nreturn ops[:i], ops[i:]\nreturn ops, []\n\nrebus = input()\nprint(solve\\_rebus(rebus))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\n\ndef solve():\n    n = int(input().strip())\n    crushes = list(map(int, input().strip().split()))\n    for t in range(1, 101):\n        already_joonjoon = [False]*n\n        for x in range(n):\n            y = x\n            while not already_joonjoon[y]:\n                already_joonjoon[y] = True\n                y = crushes[y] - 1\n            if y != x:\n                break\n        else:\n            return t\n    return -1\n\nif __name__ == '__main__':\n    print(solve())", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "from collections import Counter\nT = int(input())\nD = {0: 'First', 1: 'Second'}\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    if N % 2 == 1:\n        print((D[1]))\n    else:\n        C = Counter(A)\n        # print(C)\n        for c in C:\n            if C[c] % 2 == 1:\n                print((D[0]))\n                break\n        else:\n            print((D[1]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "a, b, c = map(int, input().split(' '))\narray = [[i for i in input()] for j in range(a)]\np = []\nx = 0\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.':\n            p = [(i, j)]\n            x += 1\n\nvisited = [[False for _ in range(b)] for i in range(a)]\ndef ok(i, j):\n    if 0 <= i <= a-1 and 0 <= j <= b-1:\n        if array[i][j] == '.':\n            return True\n    return False\n\nsa = 0\nwhile sa < x-c:\n    i, j = p[-1]\n    p.pop()\n    #print(i,j,sa)\n    if not visited[i][j]:\n        if ok(i, j-1):\n            if not visited[i][j-1]:\n                p.append((i, j-1))\n        if ok(i, j+1):\n            if not visited[i][j+1]:\n                p.append((i, j+1))\n        if ok(i+1, j):\n            if not visited[i+1][j]:\n                p.append((i+1, j))\n        if ok(i-1, j):\n            if not visited[i-1][j]:\n                p.append((i-1, j))\n        visited[i][j] = True\n        sa+=1\n\nfor i in range(a):\n    for j in range(b):\n        if array[i][j] == '.' and not visited[i][j]:\n            array[i][j] = 'X'\n\nfor each in [''.join(i) for i in array]:\n    print(each)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "MOD = 998244353\nN = int(input())\nif N == 1:\n  print((1 * pow(2, MOD - 2, MOD)))\n  return\nif N == 2:\n  print((1))\n  print((1))\n  return\n\nans = pow(2, N - 2, MOD) * N % MOD\nq = pow(pow(2, N, MOD), MOD - 2, MOD)\nfor i in range(1, N):\n  if i == 1:\n    ans += 1\n  else:\n    ans = (ans + i * pow(2, i - 2, MOD) % MOD) % MOD \nfor i in range(1, N):\n  if i == N - 1:\n    ans += N - 1\n  else:\n    ans = (ans + i * pow(2, N - 2 - i, MOD) % MOD) % MOD\n\nt = ans * q % MOD\nL = [t, t]\nfor i in range(2, (N + 1) // 2):\n  ans = (ans + (i * 2 - 1) * pow(2, (i - 1) * 2 - 1, MOD) % MOD) % MOD\n  L.append(ans * q % MOD)\n\nfor i in L:\n  print(i)\nL.reverse()\nif N % 2 == 0:\n  t = 0\nelse:\n  t = 1\nfor i in L[t:]:\n  print(i)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "from sys import stdin, stdout\nimport math, collections\nmod = 10**9+7\n\ndef isPower(n):\n    if (n <= 1):\n        return True\n    for x in range(2, (int)(math.sqrt(n)) + 1):\n        p = x\n        while (p <= n):\n            p = p * x\n            if (p == n):\n                return True\n\n    return False\nn = int(input())\narr = [0,1,2,1,4,3,2,1,5,6,2,1,8,7,5,9,8,7,3,4,7,4,2,1,10,9,3,6,11,12]\nans = arr[int(math.log(n, 2))]\ns = int(math.log(n, 2))\nfor i in range(3, int(n**0.5)+1):\n    if not isPower(i):\n        ans^=arr[int(math.log(n, i))]\n        s+=int(math.log(n, i))\nans^=((n-s)%2)\nprint(\"Vasya\" if ans else \"Petya\")", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "from sys import stdin\nfrom math import ceil\nn=int(stdin.readline().strip())\ns=tuple([0]+list(map(int,stdin.readline().strip().split()))+[0])\nlim=ceil(n/2)+1\ndp=[[2000000002 for i in  range(n+1)] for j in range(lim)]\nvis=[[False for i in  range(n+1)] for j in range(lim)]\nfor  i in range(n+1):\n    dp[0][i]=0\nans=[0 for i in range(lim-1)]\nfor i in range(1,lim):\n    for j in range(1,n+1):\n        x=0\n        y=s[j-1]\n        if vis[i-1][j-2]:\n            y=min(y,s[j-2]-1)\n        if y>=s[j]:\n            x=y-s[j]+1\n        if s[j+1]>=s[j]:\n            x+=s[j+1]-s[j]+1\n        if j==1:\n            if dp[i-1][0]+x<=dp[i][j-1]:\n                vis[i][j]=True\n                dp[i][j]=dp[i-1][0]+x\n            else:\n                dp[i][j]=dp[i][j-1]\n        else:\n            if dp[i-1][j-2]+x<=dp[i][j-1]:\n                vis[i][j]=True\n                dp[i][j]=dp[i-1][j-2]+x\n            else:\n                dp[i][j]=dp[i][j-1]\n    ans[i-1]=dp[i][-1]\nprint(*ans)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n=int(input())\nd=int(input())\ne=int(input())*5\nd,e=max(d,e),min(d,e)\nv=n\nfor i in range(e):\n    m=n-i*d\n    if m<0:\n        break\n    m%=e\n    v=min(v,m)\nprint(v)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "# Dinic's algorithm\nfrom collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nN,M = map(int,input().split())\nA = list(map(int,input().split()))\nB = list(map(int,input().split()))\nedge = [tuple(map(int,input().split())) for i in range(M)]\n\nG = Dinic(2*N+2)\nres = 0\nfor i in range(1,N+1):\n    if B[i-1]>0:\n        res += B[i-1]\n        G.add_edge(0,i,B[i-1])\n        G.add_edge(0,N+i,B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    else:\n        G.add_edge(i,2*N+1,-B[i-1])\n        res += -B[i-1]\n        G.add_edge(N+i,2*N+1,-B[i-1])\n        G.add_edge(N+i,i,A[i-1])\n    G.add_edge(i,N+i,10**15)\n\nfor u,v in edge:\n    G.add_edge(u,N+v,10**15)\n    G.add_edge(v,N+u,10**15)\n\nres -= G.flow(0,2*N+1)\n\nprint(res)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "\nM = 10 ** 5\n\nn = int(input())\nss = [int(s) for s in input().split()]\n\nprime_factor = {i: set() for i in range(1, M + 1)}\n\nfor p in range(2, M + 1):\n    if prime_factor[p] != set():\n        continue\n    else:\n        for i in range(p, M + 1, p):\n            prime_factor[i].add(p)\n\ncnt = [0] * (M + 1)\n\nfor s in ss:\n    for p in prime_factor[s]:\n        cnt[p] += 1\n\nprint(max(1, max(cnt)))", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n, m = map(int, input().split())\n\n# The maximum number of chessmen that can be placed\nmax_chessmen = (min(n, m) // 3) * 2\n\nprint(max_chessmen)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import networkx as nx\n\ndef max\\_profit():\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\nG = nx.Graph()\nfor u, v in edges:\nG.add\\_edge(u, v)\n\ntotal\\_cost = sum(a)\nmax\\_profit = -total\\_cost # initialize with the minimum possible value\n\n# iterate over all vertices\nfor v in range(1, n+1):\nG\\_v = G.copy() # create a copy of the graph\nG\\_v.remove\\_node(v) # delete vertex v\n\n# calculate the sum of B\\_i for all connected components\nscores = [sum(b[cc] for cc in c) for c in nx.connected\\_components(G\\_v)]\n\n# calculate the profit\nprofit = sum(abs(s) for s in scores) - a[v-1]\n\n# update the maximum profit\nmax\\_profit = max(max\\_profit, profit)\n\nprint(max\\_profit)\n\nif **name** == '**main**':\nmax\\_profit()", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def lieges_of_legendre():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Initialize the dynamic programming table\n    dp = [[0, 0] for _ in range(sum(a) + 1)]\n    dp[0][0] = 1  # Kevin wins if there are no cows left\n\n    # Compute the dynamic programming table\n    for i in range(n):\n        for j in range(sum(a) - a[i], -1, -1):\n            dp[j + a[i]][i % 2] += dp[j][(i + 1) % 2]\n\n    # Check if Nicky or Kevin wins\n    if dp[-1][0] == 0:\n        print(\"Kevin\")\n    else:\n        print(\"Nicky\")\n\n\nif __name__ == \"__main__\":\n    lieges_of_legendre()", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def max\\_phone\\_numbers(n, digits):\n    # Count the number of '8's in the string\n    eight\\_count = digits.count('8')\n\n    # Return 0 if there are no '8's\n    if eight\\_count == 0:\n        return 0\n\n    # Calculate the number of phone numbers that can be made\n    #", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import random\n\ndef is_valid(grid, h, w, num_white_components, num_black_components):\n    white_components = count_components(grid, h, w, 1)\n    black_components = count_components(grid, h, w, 0)\n    return white_components == num_white_components and black_components == num_black_components\n\ndef count_components(grid, h, w, color):\n    visited = [[False] * w for _ in range(h)]\n    num_components = 0\n\n    for i in range(h):\n        for j in range(w):\n            if not visited[i][j] and grid[i][j] == color:\n                num_components += 1\n                dfs(grid, i, j, h, w, visited, color)\n\n    return num_components\n\ndef dfs(grid, i, j, h, w, visited, color):\n    if i < 0 or i >= h or j < 0 or j >= w or visited[i][j] or grid[i][j] != color:\n        return\n\n    visited[i][j] = True\n    dfs(grid, i + 1, j, h, w, visited, color)\n    dfs(grid, i - 1, j, h, w, visited, color)\n    dfs(grid, i, j + 1, h, w, visited, color)\n    dfs(grid, i, j - 1, h, w, visited, color)\n\ndef generate_grid(h, w, num_white_components, num_black_components):\n    grid = [[random.randint(0, 1) for _ in range(w)] for _ in range(h)]\n\n    while not is_valid(grid, h, w, num_white_components, num_black_components):\n        grid = [[random.randint(0, 1) for _ in range(w)] for _ in range(h)]\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input())\ns = input()\n\ncnt8 = 0\nfor x in s:\n    if(x == '8'):\n        cnt8 += 1\n\nprint(min(cnt8, n // 11))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def min_remaining_rubles(n, d, e):\n    # Initialize the minimum remaining rubles as the initial sum\n    min_remaining = n\n\n    # Check all possible combinations of dollar and euro bills\n    for d_bill in [1, 2, 5, 10, 20, 50, 100]:\n        for e_bill in [5, 10, 20, 50, 100, 200]:\n            # Calculate the remaining rubles after buying one set of bills\n            remaining = n - min(d * d_bill, e * e_bill)\n\n            # Update the minimum remaining rubles if necessary\n            min_remaining = min(min_remaining, remaining)\n\n    # Return the minimum remaining rubles\n    return min_remaining\n\n# Read the input values\nn = int(input())\nd = int(input())\ne = int(input())\n\n# Print the minimum number of rubles Andrew can have\nprint(min_remaining_rubles(n, d, e))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n, k = map(int, input().split())\na = input()\nd = a[0:k]\nc = int(d)\nb=d*(n//k)\nprint(n)\nb+=d[0:n%k]\nif(b>=a):\n    print(b)\nelse:\n    c+=1\n    d=str(c)\n    b=d*(n//k)\n    b+=d[0:n%k]\n    print(b)", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "mod = 998244353\nfact = [1]\ninv = [1]\nfor i in range(1, 51):\n    fact.append((fact[-1] * i) % mod)\n    inv.append((pow(fact[-1], mod - 2, mod) * inv[-1]) % mod)\n\ndef C(n, k):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv[k] * inv[n - k] % mod\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nw = list(map(int, input().split()))\n\np = [0] * n\nq = [0] * n\nfor i in range(n):\n    if a[i] == 1:\n        p[i] = w[i]\n        q[i] = w[i]\n    else:\n        p[i] = mod - w[i]\n        q[i] = -w[i]\n\nfor _ in range(m):\n    tmp_p = [0] * n\n    tmp_q = [0] * n\n    for i in range(n):\n        if i > 0:\n            tmp_p[i] = (tmp_p[i - 1] + p[i - 1]) % mod\n        else:\n            tmp_p[i] = p[i]\n        if i > 0:\n            tmp_q[i] = (tmp_q[i - 1] + q[i - 1]) % mod\n        else:\n            tmp_q[i] = q[i]\n        if a[i] == 1:\n            tmp_q[i] = (tmp_q[i] + tmp_p[i] + q[i]) % mod\n        else:\n            tmp_q[i] = (tmp_q[i] + tmp_p[i] + mod + q[i]) % mod\n    p, q = tmp_p, tmp_q\n\nfor i in range", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n, t = map(int, input().split())\ngrade = input()\n\n# Initialize the maximum grade and the current position\nmax_grade = grade\ncurr_pos = n - 2\n\n# Loop through the remaining seconds\nfor _ in range(t):\n    # If the current position is already the most significant digit after the decimal point, break\n    if curr_pos == -1:\n        break\n\n    # Get the current digit and the next digit\n    digit, next_digit = int(grade[curr_pos + 1]), int(grade[curr_pos + 2])\n\n    # If the next digit is 5 or more, increment the current digit and set the next digits to 0\n    if next_digit >= 5:\n        grade = grade[:curr_pos + 1] + str(digit + 1) + '0' * (n - curr_pos - 2)\n        max_grade = max(max_grade, grade)\n\n    # If the next digit is less than 5, just set the next digits to 0\n    else:\n        grade = grade[:curr_pos + 1] + '0' * (n - curr_pos - 1)\n\n    # Move to the next position\n    curr_pos -= 1\n\nprint(max_grade)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "\n\n\nraw = input().split()\nvals = [x for x in input()]\nn,a,b,k = [int(x) for x in raw]\nsumm = 0\nmod = 1000000009\n\ndef inv(x):\n\treturn fast_power(x, mod-2)\n\ndef fast_power(a,n):\n\tret = 1\n\ta = a % mod\n\twhile n:\n\t\tif n&1:\n\t\t\tret = ret*a%mod\n\t\ta = a*a%mod\n\t\tn >>= 1\n\treturn ret\n\nc = inv(a) * b % mod\ncf = fast_power(c, k)\nm = (n + 1) // k\nif cf -1:\n\tp = (fast_power(cf, m) - 1) * inv(cf - 1) % mod\nelse:\n\tp = m\nx = fast_power(a, n)\nfor i in range(k):\n\tsumm = (summ + [-1, 1][vals[i] == '+'] * x * p) % mod\n\tx = (x * c) % mod\n\nprint(summ)\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\nfrom collections import deque\n\n# Read input\nN = int(sys.stdin.readline())\nsequence = list(map(int, sys.stdin.readline().split()))\n\n# Initialize max_element and max_index\nmax_element = max(sequence)\nmax_index = sequence.index(max_element)\n\n# Initialize result\nresult = [0] * (N + 1)\nresult[0] = max_element\nresult[1] = max_index + 1\n\n# Initialize operation count\noperation_count = 0\n\n# Perform operation until the length of the sequence becomes 1\nwhile len(sequence) > 1:\n    # Update max_element and max_index\n    max_element = max(sequence)\n    max_index = sequence.index(max_element)\n\n    # If the maximum element is at either end of the sequence, delete it\n    if max_index == 0 or max_index == len(sequence) - 1:\n        del sequence[max_index]\n    # Otherwise, replace it with the sum of the two elements adjacent to it and delete those two elements\n    else:\n        sequence[max_index] = sequence[max_index - 1] + sequence[max_index + 1]\n        del sequence[max_index - 1:max_index + 1]\n\n    # Update result\n    result[operation_count + 1] = max_element\n    result[operation_count + 2] = max_index + 1\n    operation_count += 1\n\n# Print result\nprint(result[-1])\nprint(operation_count)\nfor i in range(1, operation_count + 1, 2):\n    print(result[i])", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\n\nsys.setrecursionlimit(5001)\nMOD = 10 ** 9 + 7\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor line in sys.stdin.readlines():\n    x, y = list(map(int, line.split()))\n    x -= 1\n    y -= 1\n    links[x].add(y)\n    links[y].add(x)\n\ndouble_factorial_odd = [0] * (n // 2)\nprev = 1\nfor i in range(n // 2):\n    prev = double_factorial_odd[i] = (2 * i + 1) * prev % MOD\n\n\ndef dfs(v, p):\n    ret = [0, 1]\n    for u in links[v]:\n        if u == p:\n            continue\n        res = dfs(u, v)\n        lt, ls = len(ret), len(res)\n        mrg = [0] * (lt + ls - 1)\n        for i in range(1 - lt % 2, lt, 2):\n            c = ret[i]\n            for j in range(1 - ls % 2, ls, 2):\n                mrg[i + j] = (mrg[i + j] + c * res[j]) % MOD\n        ret = mrg\n\n    if len(ret) % 2 == 1:\n        ret[0] = -sum(pattern * df % MOD for pattern, df in zip(ret[2::2], double_factorial_odd)) % MOD\n\n    return ret\n\n\nprint((MOD - dfs(0, -1)[0]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import math\n\ndef min_blocked_points(n):\n    size = 2*n + 1\n    blocked = 0\n    for i in range(1, math.ceil(size/2) + 1):\n        if i <= n:\n            blocked |= (1 << (i-1)) | (1 << (size - i))\n        if i <= n - 1:\n            blocked |= (1 << (size*(i-1) + i)) | (1 << (size*(i-1) + size - i))\n    return blocked.bit_count()\n\nn = int(input())\nprint(min_blocked_points(n))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize current and next indices for Conan and Agasa\ncur\\_conan, next\\_conan, cur\\_agasa, next\\_agasa = 0, 0, 0, 0\n\n# Loop through the cards\nfor i in range(n):\n\n    # If the current card is greater than or equal to the next card for both Conan and Agasa\n    if a[cur\\_conan] >= a[next\\_conan] and a[cur\\_agasa] >= a[next\\_agasa]:\n\n        # If the current card is greater than or equal to the next card for Conan\n        if a[cur\\_conan] >= a[next\\_conan]:\n            # Move to the next card for Conan\n            cur\\_conan = next\\_conan\n            next\\_conan += 1\n\n        # If the current card is greater than or equal to the next card for Agasa\n        if a[cur\\_agasa] >= a[next\\_agasa]:\n            # Move to the next card for Agasa\n            cur\\_agasa = next\\_agasa\n            next\\_agasa += 1\n\n    # If the current card is less than the next card for both Conan and Agasa\n    elif a[cur\\_conan] < a[next\\_conan] and a[cur\\_agasa] < a[next\\_agasa]:\n\n        # If the current card is less than the next card for Conan\n        if a[cur\\_conan] < a[next\\_conan]:\n            # Move to the next card for Conan\n            cur\\_conan += 1\n\n        # If the current card is less than the next card for Agasa\n        if a[cur\\_agasa] < a[next\\_agasa]:\n            # Move to the next card for Agasa\n            cur\\_agasa += 1\n\n    # If the current card is less than the next card for one of the players and greater than or equal to the next card for the other player\n    else:\n        # If the current card is less than the next card for Agasa", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import collections\n\ndef min\\_time(n, m, volcanoes):\nif (n, n) in volcanoes:\nreturn -1\n\nqueue = collections.deque([((1, 1), 0)])\nvisited = set([(1, 1)])\n\nwhile queue:\ncurrent, time = queue.popleft()\n\nif current == (n, n):\nreturn time\n\nfor dr, dc in [(0, 1), (1, 0)]:\nnext\\_row, next\\_col = current[0] + dr, current[1] + dc\nif 1 <= next\\_row <= n and 1 <= next\\_col <= n and \\\n(next\\_row, next\\_col) not in visited and \\\n(next_row, next\\_col) not in volcanoes:\nqueue.append(((next\\_row, next\\_col), time + 1))\nvisited.add((next\\_row, next\\_col))\n\nreturn -1\n\nn, m = map(int, input().split())\nvolcanoes = set()\nfor _ in range(m):\nx, y = map(int, input().split())\nvolcanoes.add((x, y))\n\nprint(min\\_time(n, m, volcanoes))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import math\n\ndef solve(n):\n    # Place the initial knights in a 10x10 square\n    knights = [(i, j) for i in range(1, 11) for j in range(1, 11)]\n    while len(knights) > n:\n        knights.pop(math.floor(len(knights) / 2))\n    return knights\n\n# Read the input\nn = int(input())\n\n# Solve the problem\nknight_positions = solve(n)\n\n# Print the result\nfor knight in knight_positions:\n    print(*knight)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def is\\_palindrome(s):\ns = s.lower()\nreturn s == s[::-1]\n\ndef find\\_next\\_tolerable(n, p, s):\ns = list(s)\nfor i in range(n - 1, -1, -1):\nif s[i] < \"a\" + p or not is\\_palindrome(s[i:]):\nbreak\ns[i] = chr(ord(s[i]) + 1)\nfor j in range(i + 1, n):\ns[j] = \"a\"\nif is\\_palindrome(\"\".join(s[i:j + 1])):\ns[j - 1] = chr(ord(s[j - 1]) + 1)\nfor j in range(j - 1, i, -1):\ns[j] = s[j - 1]\ns[i] = chr(ord(s[i]) + 1)\nreturn \"\".join(s) if all(ord(c) <= ord(\"a\") + p for c in s) else \"NO\"\n\nn, p = map(int, input().split())\ns = input()\nprint(find\\_next\\_tolerable(n, p, s))", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input())\nfield = input()\n\nleft_most_packman, right_most_packman = -1, -1\nfor i in range(n):\n    if field[i] == 'P':\n        if left_most_packman == -1:\n            left_most_packman = i\n        right_most_packman = i\n\n# move all packmen to the leftmost packman position\ntime = 0\nwhile left_most_packman > 0:\n    left_most_packman -= 1\n    time += 1\n    right_most_packman = min(n-1, right_most_packman-1)\n    if field[right_most_packman] == '*':\n        field = field[:right_most_packman] + '.' + field[right_most_packman+1:]\n\n# eat asterisks from right to left\ntime += 1\nwhile right_most_packman < n-1:\n    right_most_packman += 1\n    time += 1\n    if field[right_most_packman] == '*':\n        field = field[:right_most_packman] + '.' + field[right_most_packman+1:]\n\nprint(time)", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\nfrom collections import deque\nn=int(input())\nvisited=[False for i in range(n+1)]\ndp=[0 for i in range(n+1)]\nl=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=list(map(int,input().split()))\n    l[a].append(b)\n    l[b].append(a)\nb=list(map(int,input().split()))\ns=[1]\nvisited[1]=True\nc=1\nc1=0\nwhile len(s)!=n :\n    aux=0\n    for i in l[s[c1]]:\n        if not visited[i]:\n            visited[i]=True\n            dp[i]=1\n            aux+=1\n    for i in range(c,c+aux):\n        if dp[b[i]]==1:\n            s.append(b[i])\n            dp[b[i]]=0\n        else:\n            print(\"No\")\n            return\n    c+=aux\n    c1+=1\nprint(\"Yes\")\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "#coding utf-8\n\ns=input().split();\nn=int(s[0]);k=int(s[1]);x=int(s[2]);\na=[[]]\ns=input().split();\nfor i in range(n):\n\ta[0].append(int(s[i]));\n\na[0].sort()\nfor i in range(1,k+1):\n\ta.append([a[i-1][t]^(x*((t+1)%2)) for t in range(len(a[i-1]))])\n\ta[i].sort()\n\tfor t in range(i):\n\t\tif a[i]==a[t]:\n\t\t\tflag=True\n\t\t\tbreak\n\tif(t!=i-1):break\n\nif(k==0):tag=0\nelif(i==k):tag=k\nelse:tag=(k-i+1)%(t-i)+i-1\n\nprint(max(a[tag]),min(a[tag]))\n\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "z=[int(p) for p in input().split()]\nm=z[2]\nlst=[]\nlst.append(z[0])\nlst.append(z[1])\ntempi=min(lst)\ntempa=max(lst)\n\ncount=0\nfibo=[]\n\n\nn=1000000000000000000\ndef fib(n):\n        \n        a, b = 0, 1\n        while b < n:\n                fibo.append(b)\n                a, b = b, a+b\n    \n\n\ndef add(m):\n        n=10**18\n        tempi=min(lst)\n        tempa=max(lst)\n        count=0\n        if(tempi>0 and tempa>0 and m>tempa):\n                fib(n)\n                for p in range(1,len(fibo)+1):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n        elif(tempi==0 or tempa==0):\n                count=1\n                fib(n)\n                tempi=tempa+(tempi)\n                for p in range(1,len(fibo)):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n\n        elif(tempi<0 and tempa>0):\n                val=(-(tempi)//tempa)+1\n                count=val\n                tempi=tempi+(val*tempa)\n                fib(n)\n                for p in range(1,len(fibo)):\n                        if(((fibo[p]*tempa)+ (fibo[p-1]*tempi))>=m):\n                                count+=p\n                                return count\n\n        \n\n\n\n\n\nif(tempi>0 and tempa>0 and m>tempa):\n        cou=add(m)\n        print(cou)\n\nelif(tempi>0 and tempa>0 and m<=tempa):\n        print(0)\n\nelif(tempi==0 ):\n        if(tempi==0 and tempa==0 and m>0):\n                print(-1)\n        elif(tempi==0 and tempa==0 and m<=0):\n                print(0)\n        elif(tempa==0 and tempi<0 and m>0):\n                print(-1)\n                \n        else:\n                cou=add(m)\n                print(cou)\nelif(tempi<0 and tempa>0):\n        if(m<=tempa):\n                print(0)\n        else:\n                cou=add(m)\n                print(cou)\nelif(tempi<0 and tempa==0):\n        if(m>0):\n                print(-1)\n        else:\n                print(0)\nelif(tempi<0 and tempa<0):\n        if(m>=0):\n                print(-1)\n        elif(m<0 and m<=tempa):\n                print(0)\n        elif(m<0 and m>tempa):\n                print(-1)\n\n        \n\n\n        \n                \n                \n                        \n                        \n                                \n                        \n                \n\n\n                        \n                        \n                        \n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "from operator import neg\nn = int(input())\na = [tuple(map(int, input().split())) for i in range(n)]\n\ndef check(max_h):\n    k = n // 2\n    b = []\n    for w, h in a:\n        if h > max_h:\n            if k <= 0 or w > max_h:\n                return 1 << 60\n            b.append((h, w))\n            k -= 1\n        else:\n            b.append((w, h))\n    b.sort(key=lambda t: t[1] - t[0])\n    r = 0\n    for w, h in b:\n        if k > 0 and w <= max_h and h < w:\n            r += h\n            k -= 1\n        else:\n            r += w\n    return r * max_h\n\nprint(min(check(h) for h in range(1, 1001)))\n    \n        \n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def gcd(a,b):\n\n    if b==0:\n\n        return a\n\n    else:\n\n        return gcd(b, a%b)\n\n    \n\ndef solve(x, y, a, b):\n\n    ans=\"\"\n\n    while not x==1 or not y==1:\n\n        if x < y:\n\n            x,y,a,b=y,x,b,a\n\n        ans+=str((x-1)//y)+a\n\n        x = x - (x-1)//y * y\n\n    print (ans)\n\n    \n\nx,y=list(map(int, input().split()))\n\nif gcd(x,y)>1:\n\n    print (\"Impossible\")\n\nelse:\n\n    solve(x,y, \"A\", \"B\")\n\n\n\n# Made By Mostafa_Khaled\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "import sys\ndef factorial():\n    nonlocal mod\n    fac = [1] * int(3e5 + 1)\n    for i in range(1, int(3e5)):\n        fac[i] = i*fac[i-1] % mod\n    return fac\ndef inverse(x):\n    nonlocal mod\n    return pow(x, mod-2, mod)\ndef C(n, r):\n    nonlocal fac\n    if n < 0 or n < r:\n        return 0\n    return fac[n]*inverse(fac[r])*inverse(fac[n-r]) % mod\ndef calc(f, w, h):\n    nonlocal mod\n    if w == 0:\n        return 1\n    ans = 0\n    for k in range(1, min(w//(h+1),f+1)+1):\n        ans += C(f+1, k) * C(w-k*h-1, k-1) % mod\n        ans %= mod\n    return ans\nf, w, h = list(map(int,sys.stdin.readline().split(' ')))\nmod = int(1e9 + 7)\nfac = factorial()\ncnt = calc(f, w, h)\nsys.stdout.write(str(cnt*inverse(C(f+w, w)) % mod))\n\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "def generate\\_string(n, memo={}):\nif n == 0:\nreturn \"What are you doing at the end of the world? Are you busy? Will you save us?\"\nif n in memo:\nreturn memo[n]\ns = f\"What are you doing while sending {generate\\_string(n-1)}? Are you busy? Will you send {generate\\_string(n-1)}?\"\nmemo[n] = s\nreturn s\n\nq = int(input().strip())\nfor _ in range(q):\nn, k = map(int, input().strip().split())\ns = generate\\_string(n)\nif len(s) < k:\nprint(\".\")\nelse:\nprint(s[k-1])", "label": 1, "label_name": "machine_generated", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
{"code": "n = int(input())\na = list(map(int, input().split()))\n\nd = [[10 ** 6] * 3 for i in range(n)]\nd[0][0] = 1\nif a[0] & 1:\n    d[0][1] = 0\nif a[0] & 2:\n    d[0][2] = 0\n\nfor i in range(1, n):\n    d[i][0] = min(d[i - 1]) + 1\n    if a[i] & 1:\n        d[i][1] = min(d[i - 1][0], d[i - 1][2])\n    if a[i] & 2:\n        d[i][2] = min(d[i - 1][0], d[i - 1][1])\n\nprint(min(d[-1]))\n", "label": 0, "label_name": "human_written", "difficulty": "competition", "original_source": "results\\Mixtral-8x7B-Instruct-v0.1-apps_competition_207.jsonl"}
